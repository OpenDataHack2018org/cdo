
static char *InfoHelp[] = {
    "NAME",
    "    info, infov, map - Information and simple statistics",
    "",
    "SYNOPSIS",
    "    <operator>  ifiles",
    "",
    "DESCRIPTION",
    "    This module writes information about the structure and contents ",
    "    of all input datasets to standard output. The information displayed ",
    "    depends on the actual operator.",
    "",
    "OPERATORS",
    "    info   Dataset information listed by code number",
    "           Prints information and simple statistics for each field of all",
    "           input datasets. For each field the operator prints one line with the following elements:",
    "           - Date and Time",
    "           - Code number and Level",
    "           - Size of the grid and number of Missing values",
    "           - Minimum, Mean and Maximum \\",
    "           The mean value is computed without the use of area weights!",
    "    infov  Dataset information listed by variable name",
    "           The same as operator info but using the name instead of the code",
    "           number to identify the variables.",
    "    map    Dataset information and simple map",
    "           Prints information, simple statistics and a map for each field of all input",
    "           datasets. The map will be printed only for fields on a rectangular grid.",
    NULL
};

static char *SinfoHelp[] = {
    "NAME",
    "    sinfo, sinfov, sinfop - Short information",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "    This module writes information about the structure of all input datasets to ",
    "    standard output. The information displayed depends on the actual operator.",
    "",
    "OPERATORS",
    "    sinfo   Short dataset information listed by code number",
    "            Prints short information of a dataset. The information is divided into",
    "            4 sections. Section 1 prints one line per variable with the following information:",
    "            - institute and source",
    "            - parameter table and code number",
    "            - horizontal grid size and number",
    "            - number of vertical levels and zaxis number",
    "            Section 2 and 3 gives a short overview of all horizontal and vertical grids.",
    "            And the last section contains short information of the time axis.",
    "    sinfov  Short dataset information listed by variable name",
    "            The same as operator sinfo but using the name instead of the code number",
    "            and parameter table to identify the variables.",
    NULL
};

static char *DiffHelp[] = {
    "NAME",
    "    diff, diffv - Compare two datasets field by field",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2",
    "",
    "DESCRIPTION",
    "    Compares the contents of two datasets field by field. The input",
    "    datasets must have the same structure and the fields must have ",
    "    the same header information and dimensions.",
    "",
    "OPERATORS",
    "    diff   Compare two datasets listed by code number",
    "           Provides statistics on differences between two datasets.",
    "           For each pair of fields the operator prints one line with the following information:",
    "           - date and time",
    "           - code number and level",
    "           - size of the grid and number of missing values",
    "           - occurrence of coefficient pairs with different signs",
    "           - occurrence of zero values",
    "           - maxima of absolute difference of coefficient pairs",
    "           - maxima of relative difference of non-zero coefficient pairs with equal signs",
    "    diffv  Compare two datasets listed by variable name",
    "           The same as operator diff. Using the name instead of the code number",
    "           to identify the variable.",
    NULL
};

static char *NinfoHelp[] = {
    "NAME",
    "    ncode, nvar, nlevel, nyear, nmon, ndate, ntime - ",
    "    Print the number of variables, levels or times",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "    This module prints, according to the actual operator,",
    "    the number of variables, levels or times of the input dataset.",
    "",
    "OPERATORS",
    "    ncode   Number of codes",
    "            Prints the number of variables with different code numbers.",
    "    nvar    Number of variables",
    "            Prints the number of variables with different names.",
    "    nlevel  Number of levels",
    "            Prints the number of levels for each variable.",
    "    nyear   Number of years",
    "            Prints the number of different years.",
    "    nmon    Number of months",
    "            Prints the number of different combinations of years and months.",
    "    ndate   Number of dates",
    "            Prints the number of different dates.",
    "    ntime   Number of time steps",
    "            Prints the number of time steps.",
    NULL
};

static char *ShowinfoHelp[] = {
    "NAME",
    "    showcode, showvar, showstdname, showlevel, showyear, showmon, showdate, ",
    "    showtime - Show variables, levels or times",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "    This module prints, according to the actual operator,",
    "    the variables, levels or times of the input dataset.",
    "",
    "OPERATORS",
    "    showcode     Show codes",
    "                 Prints the code number of all different variables.",
    "    showvar      Show variable names",
    "                 Prints the name of all different variables.",
    "    showstdname  Show standard names",
    "                 Prints the standard name of all different variables.",
    "    showlevel    Show levels",
    "                 Prints all levels for each variable.",
    "    showyear     Show years",
    "                 Prints all different years.",
    "    showmon      Show months",
    "                 Prints all different months.",
    "    showdate     Show dates",
    "                 Prints all different dates.",
    "    showtime     Show time steps",
    "                 Prints all time steps.",
    NULL
};

static char *FiledesHelp[] = {
    "NAME",
    "    vardes, griddes, vct - Dataset description",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "    This module prints, according to the actual operator, the description",
    "    of the variables, the grids or the vertical coordinate table.",
    "",
    "OPERATORS",
    "    vardes   Variable description",
    "             Prints a table with a description of all variables.",
    "             For each variable the operator prints one line listing the",
    "             code, name, description and units.",
    "    griddes  Grid description",
    "             Prints the description of all grids in a file.",
    "    vct      Vertical coordinate table",
    "             Prints the vertical coordinate table.",
    NULL
};

static char *CopyHelp[] = {
    "NAME",
    "    copy, cat - Copy datasets",
    "",
    "SYNOPSIS",
    "    <operator>  ifiles ofile",
    "",
    "DESCRIPTION",
    "    This module contains operators to copy or concatenate datasets. Each",
    "    input dataset must have the same variables with complete time steps.",
    "",
    "OPERATORS",
    "    copy  Copy datasets",
    "          Copies all input datasets to ofile. ",
    "    cat   Concatenate datasets",
    "          Concatenates all input datasets and append the result to the end ",
    "          of ofile. If ofile does not exist it will be created.",
    NULL
};

static char *ReplaceHelp[] = {
    "NAME",
    "    replace - Replace variables",
    "",
    "SYNOPSIS",
    "    replace  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    Replaces all common variables of ifile2 and ifile1 with those of ifile1",
    "    and write the result to ofile.",
    "    Both input datasets must have the same number of time steps.",
    NULL
};

static char *MergeHelp[] = {
    "NAME",
    "    merge, mergetime - Merge datasets",
    "",
    "SYNOPSIS",
    "    <operator>  ifiles ofile",
    "",
    "DESCRIPTION",
    "    This module reads datasets from several input files,",
    "    merges them and writes the resulting dataset to ofile.",
    "",
    "OPERATORS",
    "    merge      Merge datasets with different fields",
    "               Merges time series of different fields from several input datasets.",
    "               The number of fields per time step written to ofile",
    "               is the sum of the field numbers per time step in all input datasets.",
    "               The time series on all input datasets must have different fields",
    "               and the same number of time steps.",
    "    mergetime  Merge datasets sorted by date and time",
    "               Merges all time steps of all input files sorted by date and time.",
    "               After this operation every input time step is in ofile and",
    "               all time steps are sorted by date and time.",
    "               Each input file must have the same variables and different time steps.",
    NULL
};

static char *SplitHelp[] = {
    "NAME",
    "    splitcode, splitvar, splitlevel, splitgrid, splitzaxis, splitrec - ",
    "    Split a dataset",
    "",
    "SYNOPSIS",
    "    <operator>  ifile oprefix",
    "",
    "DESCRIPTION",
    "    This module splits a dataset to several files with names",
    "    formed from the field header information and oprefix.",
    "",
    "OPERATORS",
    "    splitcode   Split codes",
    "                Splits a dataset into pieces, one for each different code number.",
    "                Appends three digits with the code number to oprefix to ",
    "                form the output file names.",
    "    splitvar    Split variables",
    "                Splits a dataset into pieces, one for each variable name.",
    "                Appends a string with the variable name to oprefix to ",
    "                form the output file names.",
    "    splitlevel  Split levels",
    "                Splits a dataset into pieces, one for each different level.",
    "                Appends six digits with the level to oprefix to ",
    "                form the output file names.",
    "    splitgrid   Split grids",
    "                Splits a dataset into pieces, one for each different grid.",
    "                Appends two digits with the grid number to oprefix to ",
    "                form the output file names.",
    "    splitzaxis  Split zaxis",
    "                Splits a dataset into pieces, one for each different zaxis.",
    "                Appends two digits with the zaxis number to oprefix to ",
    "                form the output file names.",
    "    splitrec    Split records",
    "                Splits a dataset into pieces, one for each record.",
    "                Appends six digits with the record number to oprefix to ",
    "                form the output file names.",
    NULL
};

static char *SplittimeHelp[] = {
    "NAME",
    "    splithour, splitday, splitmon, splitseas, splityear - ",
    "    Split time steps of a dataset",
    "",
    "SYNOPSIS",
    "    <operator>  ifile oprefix",
    "",
    "DESCRIPTION",
    "    This module splits time steps of a dataset to several files with names",
    "    formed from the field header information and oprefix.",
    "",
    "OPERATORS",
    "    splithour  Split hours",
    "               Splits a file into pieces, one for each different hour.",
    "               Appends two digits with the hour to oprefix to ",
    "               form the output file names.",
    "    splitday   Split days",
    "               Splits a file into pieces, one for each different day.",
    "               Appends two digits with the day to oprefix to ",
    "               form the output file names.",
    "    splitmon   Split months",
    "               Splits a file into pieces, one for each different month.",
    "               Appends two digits with the month to oprefix to ",
    "               form the output file names.",
    "    splitseas  Split seasons",
    "               Splits a file into pieces, one for each different season.",
    "               Appends three characters with the season to oprefix to ",
    "               form the output file names.",
    "    splityear  Split years",
    "               Splits a file into pieces, one for each different year.",
    "               Appends four digits with the year to oprefix to ",
    "               form the output file names.",
    NULL
};

static char *SelectHelp[] = {
    "NAME",
    "    selcode, delcode, selvar, delvar, selstdname, sellevel, selgrid, selgridname, ",
    "    selzaxis, selzaxisname, seltabnum, selrec - Select fields",
    "",
    "SYNOPSIS",
    "    selcode,codes  ifile ofile",
    "    delcode,codes  ifile ofile",
    "    selvar,vars  ifile ofile",
    "    delvar,vars  ifile ofile",
    "    selstdname,stdnames  ifile ofile",
    "    sellevel,levels  ifile ofile",
    "    selgrid,grids  ifile ofile",
    "    selgridname,gridnames  ifile ofile",
    "    selzaxis,zaxes  ifile ofile",
    "    selzaxisname,zaxisnames  ifile ofile",
    "    seltabnum,tabnums  ifile ofile",
    "    selrec,records  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module selects some fields from ifile and writes them to ofile.",
    "    The fields selected depend on the actual operator and the parameters.",
    "",
    "OPERATORS",
    "    selcode       Select codes",
    "                  Selects all fields with code numbers in a user given list.",
    "    delcode       Delete codes",
    "                  Deletes all fields with code numbers in a user given list.",
    "    selvar        Select variables",
    "                  Selects all fields with variable names in a user given list.",
    "    delvar        Delete variables",
    "                  Deletes all fields with variable names in a user given list.",
    "    selstdname    Select standard names",
    "                  Selects all fields with standard names in a user given list.",
    "    sellevel      Select levels",
    "                  Selects all fields with levels in a user given list.",
    "    selgrid       Select grids",
    "                  Selects all fields with grids in a user given list.",
    "    selgridname   Select grids by name",
    "                  Selects all fields with grid names in a user given list.",
    "    selzaxis      Select zaxes",
    "                  Selects all fields with zaxes in a user given list.",
    "    selzaxisname  Select zaxes by name",
    "                  Selects all fields with zaxis names in a user given list.",
    "    seltabnum     Select parameter table numbers",
    "                  Selects all fields with parameter table numbers in a user given list.",
    "    selrec        Select records",
    "                  Selects all fields with record numbers in a user given list.",
    "                  This operator can not be used with netCDF data!",
    "",
    "PARAMETER",
    "    codes       INTEGER  Comma separated list of code numbers",
    "    vars        STRING   Comma separated list of variable names",
    "    stdnames    STRING   Comma separated list of standard names",
    "    levels      FLOAT    Comma separated list of levels",
    "    grids       INTEGER  Comma separated list of grid numbers",
    "    gridnames   STRING   Comma separated list of grid names",
    "    zaxes       INTEGER  Comma separated list of zaxis numbers",
    "    zaxisnames  STRING   Comma separated list of zaxis names",
    "    tabnums     INTEGER  Comma separated list of parameter table numbers",
    "    records     INTEGER  Comma separated list of records",
    NULL
};

static char *SeltimeHelp[] = {
    "NAME",
    "    seltimestep, seltime, selhour, selday, selmon, selyear, selseas, seldate - ",
    "    Select time steps",
    "",
    "SYNOPSIS",
    "    seltimestep,timesteps  ifile ofile",
    "    seltime,times  ifile ofile",
    "    selhour,hours  ifile ofile",
    "    selday,days  ifile ofile",
    "    selmon,months  ifile ofile",
    "    selyear,years  ifile ofile",
    "    selseas,seasons  ifile ofile",
    "    seldate,date1[,date2]  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module selects user specified time steps from ifile and writes them to ofile.",
    "    The time steps selected depend on the actual operator and the parameters.",
    "",
    "OPERATORS",
    "    seltimestep  Select time steps",
    "                 Selects all time steps with a time step in a user given list.",
    "    seltime      Select times",
    "                 Selects all time steps with a time in a user given list.",
    "    selhour      Select hours",
    "                 Selects all time steps with a hour in a user given list.",
    "    selday       Select days",
    "                 Selects all time steps with a day in a user given list.",
    "    selmon       Select months",
    "                 Selects all time steps with a month in a user given list.",
    "    selyear      Select years",
    "                 Selects all time steps with a year in a user given list.",
    "    selseas      Select seasons",
    "                 Selects all time steps with a month of a season in a user given list.",
    "    seldate      Select dates",
    "                 Selects all time steps with a date in a user given range.",
    "",
    "PARAMETER",
    "    timesteps  INTEGER  Comma separated list of time steps",
    "    times      STRING   Comma separated list of times (format hh:mm)",
    "    hours      INTEGER  Comma separated list of hours",
    "    days       INTEGER  Comma separated list of days",
    "    months     INTEGER  Comma separated list of months",
    "    years      INTEGER  Comma separated list of years",
    "    seasons    STRING   Comma separated list of seasons (DJF, MAM, JJA, SON)",
    "    date1      STRING   Start date (format YYYY-MM-DDThh:mm)",
    "    date2      STRING   End date (format YYYY-MM-DDThh:mm)",
    NULL
};

static char *SelboxHelp[] = {
    "NAME",
    "    sellonlatbox, selindexbox - Select a box of a field",
    "",
    "SYNOPSIS",
    "    sellonlatbox,lon1,lon2,lat1,lat2  ifile ofile",
    "    selindexbox,idx1,idx2,idy1,idy2  ifile ofile",
    "",
    "DESCRIPTION",
    "    Selects a box of the rectangular understood field.",
    "    All input fields must have the same horizontal grid.",
    "",
    "OPERATORS",
    "    sellonlatbox  Select a longitude/latitude box",
    "                  Selects a longitude/latitude box. The user has to give the ",
    "                  longitudes and latitudes of the edges of the box.",
    "    selindexbox   Select an index box",
    "                  Selects an index box. The user has to give the indexes of the ",
    "                  edges of the box. The index of the left edge may be greater ",
    "                  then that of the right edge.",
    "",
    "PARAMETER",
    "    lon1  FLOAT    Western longitude",
    "    lon2  FLOAT    Eastern longitude",
    "    lat1  FLOAT    Southern or northern latitude",
    "    lat2  FLOAT    Northern or southern latitude",
    "    idx1  INTEGER  Index of first longitude",
    "    idx2  INTEGER  Index of last longitude",
    "    idy1  INTEGER  Index of first latitude",
    "    idy2  INTEGER  Index of last latitude",
    NULL
};

static char *CondHelp[] = {
    "NAME",
    "    ifthen, ifnotthen - Conditional select one field",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    This module conditional selects field elements from ifile2 and writes them ",
    "    to ofile. The fields in ifile1 are handled as a mask. A value ",
    "    not equal to zero is treated as \"true\", zero is treated as \"false\".",
    "",
    "OPERATORS",
    "    ifthen     If then",
    "                        / i_2(t,x) if i_1(t,x) NE 0  AND  i_1(t,x) NE miss",
    "               o(t,x) =",
    "                        \\ miss     if i_1(t,x) EQ 0  OR   i_1(t,x) EQ miss",
    "    ifnotthen  If not then",
    "                        / i_2(t,x) if i_1(t,x) EQ 0  AND  i_1(t,x) NE miss",
    "               o(t,x) = ",
    "                        \\ miss     if i_1(t,x) NE 0  OR   i_1(t,x) EQ miss",
    NULL
};

static char *Cond2Help[] = {
    "NAME",
    "    ifthenelse - Conditional select  two fields",
    "",
    "SYNOPSIS",
    "    ifthenelse  ifile1 ifile2 ifile3 ofile",
    "",
    "DESCRIPTION",
    "    This operator conditional selects field elements from ifile2 or ifile3 and ",
    "    writes them to ofile. The fields in ifile1 are handled as a mask.",
    "    A value not equal to zero is treated as \"true\", zero is treated as \"false\".",
    "              / i_2(t,x) if i_1(t,x) NE 0  AND  i_1(t,x) NE miss",
    "    o(t,x) = <  i_3(t,x) if i_1(t,x) EQ 0  AND  i_1(t,x) NE miss",
    "              \\ miss     if i_1(t,x) EQ miss",
    NULL
};

static char *CondcHelp[] = {
    "NAME",
    "    ifthenc, ifnotthenc - Conditional select a constant",
    "",
    "SYNOPSIS",
    "    <operator>,c  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module creates fields with a constant value or missing value.",
    "    The fields in ifile1 are handled as a mask. A value not equal ",
    "    to zero is treated as \"true\", zero is treated as \"false\".",
    "",
    "OPERATORS",
    "    ifthenc     If then constant",
    "                         / c      if i(t,x) NE 0  AND  i(t,x) NE miss",
    "                o(t,x) =",
    "                         \\ miss   if i(t,x) EQ 0  OR   i(t,x) EQ miss",
    "    ifnotthenc  If not then constant",
    "                         / c      if i(t,x) EQ 0  AND  i(t,x) NE miss",
    "                o(t,x) =",
    "                         \\ miss   if i(t,x) NE 0  OR   i(t,x) EQ miss",
    "",
    "PARAMETER",
    "    c  FLOAT  Constant",
    NULL
};

static char *CompHelp[] = {
    "NAME",
    "    eq, ne, le, lt, ge, gt - Comparison of two fields",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    This module compares two datasets field by field. The resulting",
    "    field is a mask with 1 if the comparison is true and 0 if the",
    "    comparison is false. The type of the comparison depends on the",
    "    actual operator.",
    "",
    "OPERATORS",
    "    eq  Equal",
    "                  /   1   if i_1(t,x) EQ i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) NE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    ne  Not equal",
    "                  /   1   if i_1(t,x) NE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) EQ i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    le  Less equal",
    "                  /   1   if i_1(t,x) LE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) GT i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    lt  Less than",
    "                  /   1   if i_1(t,x) LT i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) GE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    ge  Greater equal",
    "                  /   1   if i_1(t,x) GE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) LT i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    gt  Greater than",
    "                  /   1   if i_1(t,x) GT i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) LE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    NULL
};

static char *CompcHelp[] = {
    "NAME",
    "    eqc, nec, lec, ltc, gec, gtc - Comparison of a field with a constant",
    "",
    "SYNOPSIS",
    "    <operator>,c  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module compares all fields of dataset with a constant. The resulting",
    "    field is a mask with 1 if the comparison is true and 0 if the comparison ",
    "    is false. The type of the comparison depends on the actual operator.",
    "",
    "OPERATORS",
    "    eqc  Equal constant",
    "                   /   1   if i(t,x) EQ c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) NE c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    nec  Not equal constant",
    "                   /   1   if i(t,x) NE c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) EQ c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    lec  Less equal constant",
    "                   /   1   if i(t,x) LE c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) GT c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    ltc  Less then constant",
    "                   /   1   if i(t,x) LT c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) GE c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    gec  Greater equal constant",
    "                   /   1   if i(t,x) GE c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) LT c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    gtc  Greater then constant",
    "                   /   1   if i(t,x) GT c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) LE c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "",
    "PARAMETER",
    "    c  FLOAT  Constant",
    NULL
};

static char *SetHelp[] = {
    "NAME",
    "    setpartab, setcode, setvar, setlevel - Set field info",
    "",
    "SYNOPSIS",
    "    setpartab,table  ifile ofile",
    "    setcode,code  ifile ofile",
    "    setvar,name  ifile ofile",
    "    setlevel,level  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module sets some field information. Depending on the actual",
    "    operator the parameter table, code number, variable name or",
    "    level is set.",
    "",
    "OPERATORS",
    "    setpartab  Set parameter table",
    "               Sets the parameter table for all variables.",
    "    setcode    Set code number",
    "               Sets the code number for all variables to the same given value.",
    "    setvar     Set variable name",
    "               Sets the name of the first variable.",
    "    setlevel   Set level",
    "               Sets the first level of all variables.",
    "",
    "PARAMETER",
    "    table  STRING   Parameter table file or name",
    "    code   INTEGER  Code number",
    "    name   STRING   Variable name",
    "    level  FLOAT    New level",
    NULL
};

static char *SettimeHelp[] = {
    "NAME",
    "    setdate, settime, setday, setmon, setyear, settunits, settaxis, setreftime, ",
    "    setcalendar, shifttime - Set time",
    "",
    "SYNOPSIS",
    "    setdate,date  ifile ofile",
    "    settime,time  ifile ofile",
    "    setday,day  ifile ofile",
    "    setmon,month  ifile ofile",
    "    setyear,year  ifile ofile",
    "    settunits,units  ifile ofile",
    "    settaxis,date,time[,inc]  ifile ofile",
    "    setreftime,date,time  ifile ofile",
    "    setcalendar,calendar  ifile ofile",
    "    shifttime,sval  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module sets the time axis or part of the time axis. Which part of the",
    "    time axis is overwritten depends on the actual operator.",
    "",
    "OPERATORS",
    "    setdate      Set date",
    "                 Sets the date in every time step to the same given value.",
    "    settime      Set time",
    "                 Sets the time in every time step to the same given value.",
    "    setday       Set day",
    "                 Sets the day in every time step to the same given value.",
    "    setmon       Set month",
    "                 Sets the month in every time step to the same given value.",
    "    setyear      Set year",
    "                 Sets the year in every time step to the same given value.",
    "    settunits    Set time units",
    "                 Sets the base units of a relative time axis.",
    "    settaxis     Set time axis",
    "                 Sets the time axis.",
    "    setreftime   Set reference time",
    "                 Sets the reference time of an relative time axis.",
    "    setcalendar  Set calendar",
    "                 Sets the calendar of an relative time axis.",
    "    shifttime    Shift time steps",
    "                 Shifts all time steps by the parameter sval.",
    "",
    "PARAMETER",
    "    day       INTEGER  Value of the new day",
    "    month     INTEGER  Value of the new month",
    "    year      INTEGER  Value of the new year",
    "    units     STRING   Base units of the time axis (minutes, hours, days, months, years).",
    "    date      STRING   Date (format YYYY-MM-DD)",
    "    time      STRING   Time (format HH:MM)",
    "    inc       STRING   Optional increment (e.g. 12hour) [default: 0hour]",
    "    calendar  STRING   Calendar (standard, 360days, 365days, 366days)",
    "    sval      STRING   Shift value (e.g. -3hour)",
    NULL
};

static char *ChangeHelp[] = {
    "NAME",
    "    chcode, chvar, chlevel, chlevelc, chlevelv - Change field header",
    "",
    "SYNOPSIS",
    "    chcode,oldcode,newcode[,...]  ifile ofile",
    "    chvar,ovar,nvar,...  ifile ofile",
    "    chlevel,oldlev,newlev,...  ifile ofile",
    "    chlevelc,code,oldlev,newlev  ifile ofile",
    "    chlevelv,var,oldlev,newlev  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module reads fields from ifile, changes some header values",
    "    and writes the results to ofile. The kind of changes depends on ",
    "    the actual operator.",
    "",
    "OPERATORS",
    "    chcode    Change code number",
    "              Changes some user given code numbers to new user given values.",
    "    chvar     Change variable name",
    "              Changes some user given variable names to new user given names.",
    "    chlevel   Change level",
    "              Changes some user given levels to new user given values.",
    "    chlevelc  Change level of one code",
    "              Changes one level of a user given code number.",
    "    chlevelv  Change level of one variable",
    "              Changes one level of a user given variable.",
    "",
    "PARAMETER",
    "    code                 INTEGER  Code number",
    "    oldcode,newcode,...  INTEGER  Pairs of old and new code numbers",
    "    var                  STRING   Variable name",
    "    ovar,nvar,...        STRING   Pairs of old and new variable names",
    "    oldlev               FLOAT    Old level",
    "    newlev               FLOAT    New level",
    "    oldlev,newlev,...    FLOAT    Pairs of old and new levels",
    NULL
};

static char *SetgridHelp[] = {
    "NAME",
    "    setgrid, setgridtype - Set grid type",
    "",
    "SYNOPSIS",
    "    setgrid,grid  ifile ofile",
    "    setgridtype,gridtype  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module sets the grid description of all fields with the same grid size",
    "    as the new grid.",
    "",
    "OPERATORS",
    "    setgrid      Set grid",
    "                 Sets the grid description of all fields.",
    "    setgridtype  Set grid type",
    "                 Sets the grid type of all grids to a user given value.",
    "",
    "PARAMETER",
    "    grid      STRING  Target grid description file or name",
    "    gridtype  STRING  Target grid type (curvilinear or cell)",
    NULL
};

static char *SetzaxisHelp[] = {
    "NAME",
    "    setzaxis - Set zaxis type",
    "",
    "SYNOPSIS",
    "    setzaxis,zaxis  ifile ofile",
    "",
    "DESCRIPTION",
    "    This operator sets the zaxis description of all variables with the",
    "    same number of level as the new zaxis.",
    "",
    "PARAMETER",
    "    zaxis  STRING  Zaxis description file or name of the target zaxis",
    NULL
};

static char *SetgattHelp[] = {
    "NAME",
    "    setgatt, setgatts - Set global attribute",
    "",
    "SYNOPSIS",
    "    setgatt,attname,attstring  ifile ofile",
    "    setgatts,attfile  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module sets global text attributes of a dataset. Depending on the actual ",
    "    operator the attributes are read from a file or can be specified by a parameter.",
    "",
    "OPERATORS",
    "    setgatt   Set global attribute",
    "              Sets one user defined global text attribute.",
    "    setgatts  Set global attributes",
    "              Sets user defined global text attributes. The name and text",
    "              of the global attributes are read from a file.",
    "",
    "PARAMETER",
    "    attname,attstring  STRING  Name and text of the global attribute (without spaces!)",
    "    attfile            STRING  File name which contains global text attributes",
    NULL
};

static char *InvertHelp[] = {
    "NAME",
    "    invertlat, invertlon, invertlatdes, invertlondes, invertlatdata, ",
    "    invertlondata - Invert fields",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module inverts 2D fields on a rectangular grid. Depending on the actual ",
    "    operator the field, only the data or only the grid description is inverted.",
    "",
    "OPERATORS",
    "    invertlat      Invert latitude",
    "                   Inverts the latitude of a field.",
    "    invertlon      Invert longitude",
    "                   Inverts the longitude of a field.",
    "    invertlatdes   Invert latitude description",
    "                   Inverts only the latitude description of a field.",
    "    invertlondes   Invert longitude description",
    "                   Inverts only the longitude description of a field.",
    "    invertlatdata  Invert latitude data",
    "                   Inverts only the latitude data of a field.",
    "    invertlondata  Invert longitude data",
    "                   Inverts only the longitude data of a field.",
    NULL
};

static char *MaskboxHelp[] = {
    "NAME",
    "    masklonlatbox, maskindexbox - Mask a box",
    "",
    "SYNOPSIS",
    "    masklonlatbox,lon1,lon2,lat1,lat2  ifile ofile",
    "    maskindexbox,idx1,idx2,idy1,idy2  ifile ofile",
    "",
    "DESCRIPTION",
    "    Masks a box of the rectangular understood field. The elements inside ",
    "    the box are untouched, the elements outside are set to missing value.",
    "    All input fields must have the same horizontal grid.",
    "",
    "OPERATORS",
    "    masklonlatbox  Mask a longitude/latitude box",
    "                   Masks a longitude/latitude box. The user has to give the ",
    "                   longitudes and latitudes of the edges of the box.",
    "    maskindexbox   Mask an index box",
    "                   Masks an index box. The user has to give the indexes of the ",
    "                   edges of the box. The index of the left edge may be greater ",
    "                   then that of the right edge.",
    "",
    "PARAMETER",
    "    lon1  FLOAT    Western longitude",
    "    lon2  FLOAT    Eastern longitude",
    "    lat1  FLOAT    Southern or northern latitude",
    "    lat2  FLOAT    Northern or southern latitude",
    "    idx1  INTEGER  Index of first longitude",
    "    idx2  INTEGER  Index of last longitude",
    "    idy1  INTEGER  Index of first latitude",
    "    idy2  INTEGER  Index of last latitude",
    NULL
};

static char *SetboxHelp[] = {
    "NAME",
    "    setclonlatbox, setcindexbox - Set a box to constant",
    "",
    "SYNOPSIS",
    "    setclonlatbox,c,lon1,lon2,lat1,lat2  ifile ofile",
    "    setcindexbox,c,idx1,idx2,idy1,idy2  ifile ofile",
    "",
    "DESCRIPTION",
    "    Sets a box of the rectangular understood field to a constant value. ",
    "    The elements outside the box are untouched, the elements inside are ",
    "    set to the given constant. All input fields must have the same ",
    "    horizontal grid.",
    "",
    "OPERATORS",
    "    setclonlatbox  Set a longitude/latitude box to constant",
    "                   Sets the values of a longitude/latitude box to a constant value. The ",
    "                   user has to give the longitudes and latitudes of the edges of the box.",
    "    setcindexbox   Set an index box to constant",
    "                   Sets the values of an index box to a constant value. The user has to ",
    "                   give the indexes of the edges of the box. The index of the left edge ",
    "                   may be greater then that of the right edge.",
    "",
    "PARAMETER",
    "    c     FLOAT    Constant",
    "    lon1  FLOAT    Western longitude",
    "    lon2  FLOAT    Eastern longitude",
    "    lat1  FLOAT    Southern or northern latitude",
    "    lat2  FLOAT    Northern or southern latitude",
    "    idx1  INTEGER  Index of first longitude",
    "    idx2  INTEGER  Index of last longitude",
    "    idy1  INTEGER  Index of first latitude",
    "    idy2  INTEGER  Index of last latitude",
    NULL
};

static char *EnlargeHelp[] = {
    "NAME",
    "    enlarge - Enlarge fields",
    "",
    "SYNOPSIS",
    "    enlarge,grid  ifile ofile",
    "",
    "DESCRIPTION",
    "    Enlarge all fields of ifile to a user given grid. Normally only the last ",
    "    field element is used for the enlargement. If however the input and output",
    "    grid are rectangular, a zonal or meridional enlargement is possible.",
    "    Zonal enlargement takes place, if the xsize of the input field is 1 and ",
    "    the ysize of both grids are the same. For meridional enlargement the ysize",
    "    must be 1 and the xsize of both grids must have the same size.",
    "",
    "PARAMETER",
    "    grid  STRING  Target grid description file or name",
    NULL
};

static char *SetmissHelp[] = {
    "NAME",
    "    setmissval, setctomiss, setmisstoc, setrtomiss - Set missing value",
    "",
    "SYNOPSIS",
    "    setmissval,miss  ifile ofile",
    "    setctomiss,c  ifile ofile",
    "    setmisstoc,c  ifile ofile",
    "    setrtomiss,rmin,rmax  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module sets part of a field to missing value or missing values",
    "    to a constant value. Which part of the field is set depends on the ",
    "    actual operator.",
    "",
    "OPERATORS",
    "    setmissval  Set a new missing value",
    "                         / miss   if i(t,x) EQ miss",
    "                o(t,x) = ",
    "                         \\ i(t,x) if i(t,x) NE miss",
    "    setctomiss  Set constant to missing value",
    "                         / miss   if i(t,x) EQ c",
    "                o(t,x) = ",
    "                         \\ i(t,x) if i(t,x) NE c",
    "    setmisstoc  Set missing value to constant",
    "                         / c      if i(t,x) EQ miss",
    "                o(t,x) = ",
    "                         \\ i(t,x) if i(t,x) NE miss",
    "    setrtomiss  Set range to missing value",
    "                         / miss   if i(t,x) GE rmin AND i(t,x) LE rmax",
    "                o(t,x) = ",
    "                         \\ i(t,x) if i(t,x) LT rmin AND i(t,x) GT rmax",
    "",
    "PARAMETER",
    "    miss  FLOAT  New missing value",
    "    c     FLOAT  Constant",
    "    rmin  FLOAT  Lower bound",
    "    rmax  FLOAT  Upper bound",
    NULL
};

static char *ExprHelp[] = {
    "NAME",
    "    expr, exprf - Evaluate expressions",
    "",
    "SYNOPSIS",
    "    expr,instr  ifile ofile",
    "    exprf,filename  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module arithmetically processes every time step of the input dataset.",
    "    Each individual assignment statement must end with a semi-colon.",
    "    The basic arithmetic operations addition +, subtraction -, multiplication *,",
    "    division / and exponentiation ^ can be used.",
    "    The following intrinsic functions are available:",
    "    sqrt(x) "    "    Square Root of x",
    "    exp(x)  "    "    Exponential of x",
    "    log(x)  "    "    Natural logarithm of x",
    "    log10(x)"    "    Base 10 logarithm of x",
    "    sin(x)  "    "    Sine of x, where x is specified in radians",
    "    cos(x)  "    "    Cosine of x, where x is specified in radians",
    "    tan(x)  "    "    Tangent of x, where x is specified in radians",
    "    asin(x) "    "    Arc-sine of x, where x is specified in radians",
    "    acos(x) "    "    Arc-cosine of x, where x is specified in radians",
    "    atan(x) "    "    Arc-tangent of x, where x is specified in radians",
    "",
    "OPERATORS",
    "    expr   Evaluate expressions",
    "           The processing instructions are read from the parameter.",
    "    exprf  Evaluate expressions from script file",
    "           Contrary to expr the processing instructions are read from a file.",
    "",
    "PARAMETER",
    "    instr     STRING  Processing instructions (without spaces!)",
    "    filename  STRING  File with processing instructions",
    NULL
};

static char *MathHelp[] = {
    "NAME",
    "    abs, int, nint, sqr, sqrt, exp, ln, log10, sin, cos, tan, asin, acos, atan - ",
    "    Mathematical functions",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module contains some standard mathematical functions.",
    "    All trigonometric functions calculate with radians.",
    "",
    "OPERATORS",
    "    abs    Absolute value",
    "           o(t,x) = abs(i(t,x))",
    "    int    Integer value",
    "           o(t,x) = int(i(t,x))",
    "    nint   Nearest integer value",
    "           o(t,x) = nint(i(t,x))",
    "    sqr    Square",
    "           o(t,x) = i(t,x)**2",
    "    sqrt   Square root",
    "           o(t,x) = sqrt(i(t,x))",
    "    exp    Exponential",
    "           o(t,x) = e**i(t,x)",
    "    ln     Natural logarithm",
    "           o(t,x) = ln(i(t,x))",
    "    log10  Base 10 logarithm",
    "           o(t,x) = log10(i(t,x))",
    "    sin    Sine",
    "           o(t,x) = sin(i(t,x))",
    "    cos    Cosine",
    "           o(t,x) = cos(i(t,x))",
    "    tan    Tangent",
    "           o(t,x) = tan(i(t,x))",
    "    asin   Arc sine",
    "           o(t,x) = asin(i(t,x))",
    "    acos   Arc cosine",
    "           o(t,x) = acos(i(t,x))",
    "    atan   Arc tangent",
    "           o(t,x) = atan(i(t,x))",
    NULL
};

static char *ArithcHelp[] = {
    "NAME",
    "    addc, subc, mulc, divc - Arithmetic with a constant",
    "",
    "SYNOPSIS",
    "    <operator>,c  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module performs simple arithmetic with all field elements of a dataset and ",
    "    a constant. The header and date information in ofile is the same as in ifile.",
    "",
    "OPERATORS",
    "    addc  Add a constant",
    "          o(t,x) = i(t,x) + c",
    "    subc  Subtract a constant",
    "          o(t,x) = i(t,x) - c",
    "    mulc  Multiply with a constant",
    "          o(t,x) = i(t,x) * c",
    "    divc  Divide by a constant",
    "          o(t,x) = i(t,x) / c",
    "",
    "PARAMETER",
    "    c  FLOAT  Constant",
    NULL
};

static char *ArithHelp[] = {
    "NAME",
    "    add, sub, mul, div, min, max, atan2 - Arithmetic on two datasets",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    This module performs simple arithmetic of two datasets.",
    "    The header and date information in ofile is the same as in ifile1.",
    "",
    "OPERATORS",
    "    add    Add two fields",
    "           o(t,x) = i_1(t,x) + i_2(t,x)",
    "    sub    Subtract two fields",
    "           o(t,x) = i_1(t,x) - i_2(t,x)",
    "    mul    Multiply two fields",
    "           o(t,x) = i_1(t,x) * i_2(t,x)",
    "    div    Divide two fields",
    "           o(t,x) = i_1(t,x) / i_2(t,x)",
    "    min    Minimum of two fields",
    "           o(t,x) = min(i_1(t,x), i_2(t,x))",
    "    max    Maximum of two fields",
    "           o(t,x) = max(i_1(t,x), i_2(t,x))",
    "    atan2  Arc tangent of two fields",
    "           The atan2 operator calculates the arc tangent of two fields. The result is",
    "           in radians, which is between -PI and PI (inclusive).",
    "           ",
    "           o(t,x) = atan2(i_1(t,x), i_2(t,x))",
    NULL
};

static char *YmonarithHelp[] = {
    "NAME",
    "    ymonadd, ymonsub, ymonmul, ymondiv - Multi-year monthly arithmetic",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    This module performs simple arithmetic of a time series and a",
    "    time step with the same month of year. For each field in ifile1",
    "    the corresponding field of the time step in ifile2 with the",
    "    same month of year is used. The header information in ifile1",
    "    must be the same as in ifile2. Usually ifile2 is generated",
    "    by a call of the module YMONSTAT.",
    "",
    "OPERATORS",
    "    ymonadd  Add multi-year monthly time average",
    "             Adds a time series and a multi-year monthly time average.",
    "    ymonsub  Subtract multi-year monthly time average",
    "             Subtracts a time series and a multi-year monthly time average.",
    "    ymonmul  Multiply multi-year monthly time average",
    "             Multiplies a time series and a multi-year monthly time average.",
    "    ymondiv  Divide multi-year monthly time average",
    "             Divides a time series and a multi-year monthly time average.",
    NULL
};

static char *ArithdaysHelp[] = {
    "NAME",
    "    muldpm, divdpm, muldpy, divdpy - Arithmetic with days",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module multiplies or divides each time step of a dataset with the corresponding",
    "    days per month or days per year.",
    "",
    "OPERATORS",
    "    muldpm  Multiply with days per month",
    "            o(t,x) = i(t,x) * days\\_per\\_month",
    "    divdpm  Divide by days per month",
    "            o(t,x) = i(t,x) / days\\_per\\_month",
    "    muldpy  Multiply with days per year",
    "            o(t,x) = i(t,x) * days\\_per\\_year",
    "    divdpy  Divide by days per year",
    "            o(t,x) = i(t,x) / days\\_per\\_year",
    NULL
};

static char *EnsstatHelp[] = {
    "NAME",
    "    ensmin, ensmax, enssum, ensmean, ensavg, ensstd, ensvar - ",
    "    Statistical values over an ensemble",
    "",
    "SYNOPSIS",
    "    <operator>  ifiles ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over an ensemble of input files.",
    "    Depending on the actual operator the minimum, maximum, sum, average",
    "    or standard deviation over all input files is written to ofile. The date ",
    "    information for a time step in ofile is the date of the first input file.",
    "",
    "OPERATORS",
    "    ensmin   Ensemble minimum",
    "             o(t,x) = min{i1(t,x), i2(t,x), ..., in(t,x)}",
    "    ensmax   Ensemble maximum",
    "             o(t,x) = max{i1(t,x), i2(t,x), ..., in(t,x)}",
    "    enssum   Ensemble sum",
    "             o(t,x) = sum{i1(t,x), i2(t,x), ..., in(t,x)}",
    "    ensmean  Ensemble mean",
    "             o(t,x) = mean{i1(t,x), i2(t,x), ..., in(t,x)}",
    "    ensavg   Ensemble average",
    "             o(t,x) = avg{i1(t,x), i2(t,x), ..., in(t,x)}",
    "    ensstd   Ensemble standard deviation",
    "             o(t,x) = std{i1(t,x), i2(t,x), ..., in(t,x)}",
    "    ensvar   Ensemble variance",
    "             o(t,x) = var{i1(t,x), i2(t,x), ..., in(t,x)}",
    NULL
};

static char *FldstatHelp[] = {
    "NAME",
    "    fldmin, fldmax, fldsum, fldmean, fldavg, fldstd, fldvar - ",
    "    Statistical values over a field",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values of the input fields.",
    "    According to the actual operator the field minimum, maximum,",
    "    sum, average, standard deviation or variance is written to ofile.",
    "",
    "OPERATORS",
    "    fldmin   Field minimum",
    "             For every gridpoint x_1, ..., x_n of the same field, it is:",
    "             ",
    "             o(t,1) = min{i(t,x'), x_1<x'<=x_n}",
    "    fldmax   Field maximum",
    "             For every gridpoint x_1, ..., x_n of the same field, it is:",
    "             ",
    "             o(t,1) = max{i(t,x'), x_1<x'<=x_n}",
    "    fldsum   Field sum",
    "             For every gridpoint x_1, ..., x_n of the same field, it is:",
    "             ",
    "             o(t,1) = sum{i(t,x'), x_1<x'<=x_n}",
    "    fldmean  Field mean",
    "             For every gridpoint x_1, ..., x_n of the same field, it is:",
    "             ",
    "             o(t,1) = mean{i(t,x'), x_1<x'<=x_n}",
    "             weighted by area weights obtained by the input field.",
    "    fldavg   Field average",
    "             For every gridpoint x_1, ..., x_n of the same field, it is:",
    "             ",
    "             o(t,1) = avg{i(t,x'), x_1<x'<=x_n}",
    "             weighted by area weights obtained by the input field.",
    "    fldstd   Field standard deviation",
    "             For every gridpoint x_1, ..., x_n of the same field, it is:",
    "             ",
    "             o(t,1) = std{i(t,x'), x_1<x'<=x_n}",
    "             weighted by area weights obtained by the input field.",
    "    fldvar   Field variance",
    "             For every gridpoint x_1, ..., x_n of the same field, it is:",
    "             ",
    "             o(t,1) = var{i(t,x'), x_1<x'<=x_n}",
    "             weighted by area weights obtained by the input field.",
    NULL
};

static char *ZonstatHelp[] = {
    "NAME",
    "    zonmin, zonmax, zonsum, zonmean, zonavg, zonstd, zonvar - ",
    "    Zonal statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes zonal statistical values of the input fields.",
    "    According to the actual operator the zonal minimum, maximum, ",
    "    sum, average, standard deviation or variance is written to ofile.",
    "    All input fields must have the same rectangular grid. ",
    "",
    "OPERATORS",
    "    zonmin   Zonal minimum",
    "             For every latitude the minimum over all longitudes is computed.",
    "    zonmax   Zonal maximum",
    "             For every latitude the maximum over all longitudes is computed.",
    "    zonsum   Zonal sum",
    "             For every latitude the sum over all longitudes is computed.",
    "    zonmean  Zonal mean",
    "             For every latitude the mean over all longitudes is computed.",
    "    zonavg   Zonal average",
    "             For every latitude the average over all longitudes is computed.",
    "    zonstd   Zonal standard deviation",
    "             For every latitude the standard deviation over all longitudes is computed.",
    "    zonvar   Zonal variance",
    "             For every latitude the variance over all longitudes is computed.",
    NULL
};

static char *MerstatHelp[] = {
    "NAME",
    "    mermin, mermax, mersum, mermean, meravg, merstd, mervar - ",
    "    Meridional statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes meridional statistical values of the input fields.",
    "    According to the actual operator the meridional minimum, maximum,",
    "    sum, average, standard deviation or variance is written to ofile.",
    "    All input fields must have the same rectangular grid. ",
    "",
    "OPERATORS",
    "    mermin   Meridional minimum",
    "             For every longitude the minimum over all latitudes is computed.",
    "    mermax   Meridional maximum",
    "             For every longitude the maximum over all latitudes is computed.",
    "    mersum   Meridional sum",
    "             For every longitude the sum over all latitudes is computed.",
    "    mermean  Meridional mean",
    "             For every longitude the area weighted mean over all latitudes is computed.",
    "    meravg   Meridional average",
    "             For every longitude the area weighted average over all latitudes is computed.",
    "    merstd   Meridional standard deviation",
    "             For every longitude the standard deviation over all latitudes is computed.",
    "    mervar   Meridional variance",
    "             For every longitude the variance over all latitudes is computed.",
    NULL
};

static char *VertstatHelp[] = {
    "NAME",
    "    vertmin, vertmax, vertsum, vertmean, vertavg, vertstd - ",
    "    Vertical statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over all levels of the input variables.",
    "    According to actual operator the vertical minimum, maximum, sum, average, ",
    "    standard deviation or variance is written to ofile.",
    "",
    "OPERATORS",
    "    vertmin   Vertical minimum",
    "              For every gridpoint the minimum over all levels is computed.",
    "    vertmax   Vertical maximum",
    "              For every gridpoint the maximum over all levels is computed.",
    "    vertsum   Vertical sum",
    "              For every gridpoint the sum over all levels is computed.",
    "    vertmean  Vertical mean",
    "              For every gridpoint the mean over all levels is computed.",
    "    vertavg   Vertical average",
    "              For every gridpoint the average over all levels is computed.",
    "    vertstd   Vertical standard deviation",
    "              For every gridpoint the standard deviation over all levels is computed.",
    NULL
};

static char *SelstatHelp[] = {
    "NAME",
    "    selmin, selmax, selsum, selmean, selavg, selstd - Time range statistical values",
    "",
    "SYNOPSIS",
    "    <operator>,nsets[,noffset[,nskip]]  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values for a selected number of time steps.",
    "    According to the actual operator the average, minimum, maximum, sum, average ",
    "    or standard deviation of the selected time steps is written to ofile.",
    "",
    "OPERATORS",
    "    selmin   Time range minimum",
    "             For every adjacent sequence t1, ...., tn of time steps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = min{i(t',x), t1 < t' <= tn}",
    "    selmax   Time range maximum",
    "             For every adjacent sequence t1, ...., tn of time steps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = max{i(t',x), t1 < t' <= tn}",
    "    selsum   Time range sum",
    "             For every adjacent sequence t1, ...., tn of time steps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = sum{i(t',x), t1 < t' <= tn}",
    "    selmean  Time range mean",
    "             For every adjacent sequence t1, ...., tn of time steps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = mean{i(t',x), t1 < t' <= tn}",
    "    selavg   Time range average",
    "             For every adjacent sequence t1, ...., tn of time steps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = avg{i(t',x), t1 < t' <= tn}",
    "    selstd   Time range standard deviation",
    "             For every adjacent sequence t1, ...., tn of time steps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = sqrt{var{i(t',x), t1 < t' <= tn}}",
    "",
    "PARAMETER",
    "    nsets    INTEGER  Number of input time steps for each output time step",
    "    noffset  INTEGER  Number of input time steps skipped before the first time step range (optional)",
    "    nskip    INTEGER  Number of input time steps skipped between time step ranges (optional)",
    NULL
};

static char *RunstatHelp[] = {
    "NAME",
    "    runmin, runmax, runsum, runmean, runavg, runstd - Running statistical values",
    "",
    "SYNOPSIS",
    "    <operator>,nts  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes running statistical values over a selected number",
    "    of time steps. Depending on the actual operator the minimum, maximum,",
    "    sum, average or standard deviation of a selected number of consecutive ",
    "    time steps read from ifile is written to ofile. The date information ",
    "    in ofile is the date of the medium contributing time step in ifile.",
    "",
    "OPERATORS",
    "    runmin   Running minimum",
    "             o(t+(nts-1)/2,x) = min{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runmax   Running maximum",
    "             o(t+(nts-1)/2,x) = max{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runsum   Running sum",
    "             o(t+(nts-1)/2,x) = sum{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runmean  Running mean",
    "             o(t+(nts-1)/2,x) = mean{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runavg   Running average",
    "             o(t+(nts-1)/2,x) = avg{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runstd   Running standard deviation",
    "             o(t+(nts-1)/2,x) = sqrt{var{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}}",
    "",
    "PARAMETER",
    "    nts  INTEGER  Number of time steps",
    NULL
};

static char *TimstatHelp[] = {
    "NAME",
    "    timmin, timmax, timsum, timmean, timavg, timstd - ",
    "    Statistical values over all time steps",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical  values over all time steps in ifile.",
    "    Depending on the actual operator the minimum, maximum, sum, average",
    "    or standard deviation of all time steps read from ifile is written to ofile.",
    "    The date information for a time step in ofile is the date of the last ",
    "    contributing time step in ifile.",
    "",
    "OPERATORS",
    "    timmin   Time minimum",
    "             o(1,x) = min{i(t',x), t_1<t'<=t_n}",
    "    timmax   Time maximum",
    "             o(1,x) = max{i(t',x), t_1<t'<=t_n}",
    "    timsum   Time sum",
    "             o(1,x) = sum{i(t',x), t_1<t'<=t_n}",
    "    timmean  Time mean",
    "             o(1,x) = mean{i(t',x), t_1<t'<=t_n}",
    "    timavg   Time average",
    "             o(1,x) = avg{i(t',x), t_1<t'<=t_n}",
    "    timstd   Time standard deviation",
    "             o(1,x) = std{i(t',x), t_1<t'<=t_n}",
    NULL
};

static char *HourstatHelp[] = {
    "NAME",
    "    hourmin, hourmax, hoursum, hourmean, houravg, hourstd - ",
    "    Hourly statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over time steps of the same hour.",
    "    Depending on the actual operator the minimum, maximum, sum, average ",
    "    or standard deviation of time steps of the same hour is written to ofile.",
    "    The date information for a time step in ofile is the date of the last ",
    "    contributing time step in ifile.",
    "",
    "OPERATORS",
    "    hourmin   Hourly minimum",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same hour, it is",
    "              ",
    "              o(t,x) = min{i(t',x), t_1<t'<=t_n}",
    "    hourmax   Hourly maximum",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same hour, it is",
    "              ",
    "              o(t,x) = max{i(t',x), t_1<t'<=t_n}",
    "    hoursum   Hourly sum",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same hour, it is",
    "              ",
    "              o(t,x) = sum{i(t',x), t_1<t'<=t_n}",
    "    hourmean  Hourly mean",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same hour, it is",
    "              ",
    "              o(t,x) = mean{i(t',x), t_1<t'<=t_n}",
    "    houravg   Hourly average",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same hour, it is",
    "              ",
    "              o(t,x) = avg{i(t',x), t_1<t'<=t_n}",
    "    hourstd   Hourly standard deviation",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same hour, it is",
    "              ",
    "              o(t,x) = std{i(t',x), t_1<t'<=t_n}",
    NULL
};

static char *DaystatHelp[] = {
    "NAME",
    "    daymin, daymax, daysum, daymean, dayavg, daystd - Daily statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over time steps of the same day.",
    "    Depending on the actual operator the minimum, maximum, sum, average",
    "    or standard deviation of time steps of the same day is written to ofile.",
    "    The date information for a time step in ofile is the date of the last ",
    "    contributing time step in ifile.",
    "",
    "OPERATORS",
    "    daymin   Daily minimum",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same day, it is",
    "             ",
    "             o(t,x) = min{i(t',x), t_1<t'<=t_n}",
    "    daymax   Daily maximum",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same day, it is",
    "             ",
    "             o(t,x) = max{i(t',x), t_1<t'<=t_n}",
    "    daysum   Daily sum",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same day, it is",
    "             ",
    "             o(t,x) = sum{i(t',x), t_1<t'<=t_n}",
    "    daymean  Daily mean",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same day, it is",
    "             ",
    "             o(t,x) = mean{i(t',x), t_1<t'<=t_n}",
    "    dayavg   Daily average",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same day, it is",
    "             ",
    "             o(t,x) = avg{i(t',x), t_1<t'<=t_n}",
    "    daystd   Daily standard deviation",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same day, it is",
    "             ",
    "             o(t,x) = std{i(t',x), t_1<t'<=t_n}",
    NULL
};

static char *MonstatHelp[] = {
    "NAME",
    "    monmin, monmax, monsum, monmean, monavg, monstd - Monthly statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over time steps of the same month.",
    "    Depending on the actual operator the minimum, maximum, sum, average ",
    "    or standard deviation of time steps of the same month is written to ofile.",
    "    The date information for a time step in ofile is the date of the last ",
    "    contributing time step in ifile.",
    "",
    "OPERATORS",
    "    monmin   Monthly minimum",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is:",
    "             ",
    "             o(t,x) = min{i(t',x), t_1<t'<=t_n}",
    "    monmax   Monthly maximum",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "             ",
    "             o(t,x) = max{i(t',x), t_1<t'<=t_n}",
    "    monsum   Monthly sum",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "             ",
    "             o(t,x) = sum{i(t',x), t_1<t'<=t_n}",
    "    monmean  Monthly mean",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "             ",
    "             o(t,x) = mean{i(t',x), t_1<t'<=t_n}",
    "    monavg   Monthly average",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "             ",
    "             o(t,x) = avg{i(t',x), t_1<t'<=t_n}",
    "    monstd   Monthly standard deviation",
    "             For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "             ",
    "             o(t,x) = std{i(t',x), t_1 < t' <= t_n}",
    NULL
};

static char *YearstatHelp[] = {
    "NAME",
    "    yearmin, yearmax, yearsum, yearmean, yearavg, yearstd - ",
    "    Yearly statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over time steps of the same year.",
    "    Depending on the actual operator the minimum, maximum, sum, average ",
    "    or standard deviation of time steps of the same year is written to ofile.",
    "    The date information for a time step in ofile is the date of the last ",
    "    contributing time step in ifile.",
    "",
    "OPERATORS",
    "    yearmin   Yearly minimum",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same year, it is",
    "              ",
    "              o(t,x) = min{i(t',x), t_1<t'<=t_n}",
    "    yearmax   Yearly maximum",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same year, it is",
    "              ",
    "              o(t,x) = max{i(t',x), t_1<t'<=t_n}",
    "    yearsum   Yearly sum",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same year, it is",
    "              ",
    "              o(t,x) = sum{i(t',x), t_1<t'<=t_n}",
    "    yearmean  Yearly mean",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same year, it is",
    "              ",
    "              o(t,x) = mean{i(t',x), t_1<t'<=t_n}",
    "    yearavg   Yearly average",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same year, it is",
    "              ",
    "              o(t,x) = avg{i(t',x), t_1<t'<=t_n}",
    "    yearstd   Yearly standard deviation",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same year, it is",
    "              ",
    "              o(t,x) = std{i(t',x), t_1 < t' <= t_n}",
    NULL
};

static char *SeasstatHelp[] = {
    "NAME",
    "    seasmin, seasmax, seassum, seasmean, seasavg, seasstd - ",
    "    Seasonally statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over time steps of the same season.",
    "    Depending on the actual operator the minimum, maximum, sum, average ",
    "    or standard deviation of time steps of the same season is written to ofile.",
    "    The date information for a time step in ofile is the date of the last ",
    "    contributing time step in ifile. Be careful about the first and the last ",
    "    output time step, they may be incorrect values if the seasons have incomplete ",
    "    time steps.",
    "",
    "OPERATORS",
    "    seasmin   Seasonally minimum",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "              ",
    "              o(t,x) = min{i(t',x), t1 < t' <= tn}",
    "    seasmax   Seasonally maximum",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "              ",
    "              o(t,x) = max{i(t',x), t1 < t' <= tn}",
    "    seassum   Seasonally sum",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "              ",
    "              o(t,x) = sum{i(t',x), t1 < t' <= tn}",
    "    seasmean  Seasonally mean",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "              ",
    "              o(t,x) = mean{i(t',x), t1 < t' <= tn}",
    "    seasavg   Seasonally average",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "              ",
    "              o(t,x) = avg{i(t',x), t1 < t' <= tn}",
    "    seasstd   Seasonally standard deviation",
    "              For every adjacent sequence t_1, ...,t_n of time steps of the same month, it is",
    "              ",
    "              o(t,x) = std{i(t',x), t1 < t' <= tn}",
    NULL
};

static char *YdaystatHelp[] = {
    "NAME",
    "    ydaymin, ydaymax, ydaymean, ydayavg, ydaystd - ",
    "    Multi-year daily statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module writes to ofile, according to the actual operator,",
    "    the minimum, maximum, sum, average or standard deviation of each ",
    "    day of year in ifile. The date information in an output field is ",
    "    the date of the last contributing input field.",
    "",
    "OPERATORS",
    "    ydaymin   Multi-year daily minimum",
    "              o(001,x) = min{i(t,x), day(i(t)) = 001}",
    "                               ...",
    "              o(366,x) = min{i(t,x), day(i(t)) = 366}",
    "    ydaymax   Multi-year daily maximum",
    "              o(001,x) = max{i(t,x), day(i(t)) = 001}",
    "                               ...",
    "              o(366,x) = max{i(t,x), day(i(t)) = 366}",
    "    ydaymean  Multi-year daily mean",
    "              o(001,x) = mean{i(t,x), day(i(t)) = 001}",
    "                               ...",
    "              o(366,x) = mean{i(t,x), day(i(t)) = 366}",
    "    ydayavg   Multi-year daily average",
    "              o(001,x) = avg{i(t,x), day(i(t)) = 001}",
    "                               ...",
    "              o(366,x) = avg{i(t,x), day(i(t)) = 366}",
    "    ydaystd   Multi-year daily standard deviation",
    "              o(001,x) = std{i(t,x), day(i(t)) = 001}",
    "                               ...",
    "              o(366,x) = std{i(t,x), day(i(t)) = 366}",
    NULL
};

static char *YmonstatHelp[] = {
    "NAME",
    "    ymonmin, ymonmax, ymonmean, ymonavg, ymonstd - ",
    "    Multi-year monthly statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module writes to ofile, according to the actual operator,",
    "    the minimum, maximum, sum, average or standard deviation  of each ",
    "    month of year in ifile. The date information in an output field is ",
    "    the date of the last contributing input field.",
    "",
    "OPERATORS",
    "    ymonmin   Multi-year monthly minimum",
    "              o(01,x) = min{i(t,x), month(i(t)) = 01}",
    "                               ...",
    "              o(12,x) = min{i(t,x), month(i(t)) = 12}",
    "    ymonmax   Multi-year monthly maximum",
    "              o(01,x) = max{i(t,x), month(i(t)) = 01}",
    "                               ...",
    "              o(12,x) = max{i(t,x), month(i(t)) = 12}",
    "    ymonmean  Multi-year monthly mean",
    "              o(01,x) = mean{i(t,x), month(i(t)) = 01}",
    "                               ...",
    "              o(12,x) = mean{i(t,x), month(i(t)) = 12}",
    "    ymonavg   Multi-year monthly average",
    "              o(01,x) = avg{i(t,x), month(i(t)) = 01}",
    "                               ...",
    "              o(12,x) = avg{i(t,x), month(i(t)) = 12}",
    "    ymonstd   Multi-year monthly standard deviation",
    "              o(01,x) = std{i(t,x), month(i(t)) = 01}",
    "                               ...",
    "              o(12,x) = std{i(t,x), month(i(t)) = 12}",
    NULL
};

static char *YseasstatHelp[] = {
    "NAME",
    "    yseasmin, yseasmax, yseasmean, yseasavg, yseasstd - ",
    "    Multi-year seasonally statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module writes to ofile, according to the actual operator,",
    "    the minimum, maximum, sum, average or standard deviation  of each ",
    "    season in ifile. The date information in an output field is the date",
    "    of the last contributing input field.",
    "",
    "OPERATORS",
    "    yseasmin   Multi-year seasonally minimum",
    "               o(1,x) = min{i(t,x), month(i(t)) = 12, 01, 02}",
    "               o(2,x) = min{i(t,x), month(i(t)) = 03, 04, 05}",
    "               o(3,x) = min{i(t,x), month(i(t)) = 06, 07, 08}",
    "               o(4,x) = min{i(t,x), month(i(t)) = 09, 10, 11}",
    "    yseasmax   Multi-year seasonally maximum",
    "               o(1,x) = max{i(t,x), month(i(t)) = 12, 01, 02}",
    "               o(2,x) = max{i(t,x), month(i(t)) = 03, 04, 05}",
    "               o(3,x) = max{i(t,x), month(i(t)) = 06, 07, 08}",
    "               o(4,x) = max{i(t,x), month(i(t)) = 09, 10, 11}",
    "    yseasmean  Multi-year seasonally mean",
    "               o(1,x) = mean{i(t,x), month(i(t)) = 12, 01, 02}",
    "               o(2,x) = mean{i(t,x), month(i(t)) = 03, 04, 05}",
    "               o(3,x) = mean{i(t,x), month(i(t)) = 06, 07, 08}",
    "               o(4,x) = mean{i(t,x), month(i(t)) = 09, 10, 11}",
    "    yseasavg   Multi-year seasonally average",
    "               o(1,x) = avg{i(t,x), month(i(t)) = 12, 01, 02}",
    "               o(2,x) = avg{i(t,x), month(i(t)) = 03, 04, 05}",
    "               o(3,x) = avg{i(t,x), month(i(t)) = 06, 07, 08}",
    "               o(4,x) = avg{i(t,x), month(i(t)) = 09, 10, 11}",
    "    yseasstd   Multi-year seasonally standard deviation",
    "               o(1,x) = std{i(t,x), month(i(t)) = 12, 01, 02}",
    "               o(2,x) = std{i(t,x), month(i(t)) = 03, 04, 05}",
    "               o(3,x) = std{i(t,x), month(i(t)) = 06, 07, 08}",
    "               o(4,x) = std{i(t,x), month(i(t)) = 09, 10, 11}",
    NULL
};

static char *DetrendHelp[] = {
    "NAME",
    "    detrend - Detrend time series",
    "",
    "SYNOPSIS",
    "    detrend  ifile ofile",
    "",
    "DESCRIPTION",
    "    Every time series in ifile is linearly detrended. For every field element x ",
    "    only those time steps t belong to the sample S(x), which have i(t,x) NE miss.",
    "    This operator has to keep the fields of all time steps concurrently in the memory.",
    "    If not enough memory is available, use the operators trend and subtrend.",
    NULL
};

static char *TrendHelp[] = {
    "NAME",
    "    trend - Trend of time series",
    "",
    "SYNOPSIS",
    "    trend  ifile ofile1 ofile2",
    "",
    "DESCRIPTION",
    "    The values of the input file ifile are assumed to be distributed as",
    "    N(a+b*t,S^2) with unknown a, b and S^2. This operator estimates the",
    "    parameter a and b. For every field element x only those time steps ",
    "    t belong to the sample S(x), which have i(t,x) NE miss.",
    "    Thus the estimation for a is stored in ofile1 and that for b is stored ",
    "    in ofile2. To subtract the trend from the data see operator subtrend.",
    NULL
};

static char *SubtrendHelp[] = {
    "NAME",
    "    subtrend - Subtract a trend",
    "",
    "SYNOPSIS",
    "    subtrend  ifile1 ifile2 ifile3 ofile",
    "",
    "DESCRIPTION",
    "    This operator is for subtracting a trend computed by the operator trend.",
    "    It is",
    "    ",
    "    o(t,x) = i_1(t,x) - (i_2(1,x) + i_3(1,x)*t)",
    "    where t is the time steps.",
    NULL
};

static char *RemapgridHelp[] = {
    "NAME",
    "    remapbil, remapbic, remapcon, remapdis - SCRIP grid interpolation",
    "",
    "SYNOPSIS",
    "    <operator>,grid  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module contains operators to interpolate all input fields to a new grid.",
    "    Each operator is using a different remapping method. The interpolation is based",
    "    on a special SCRIP library version. For a detailed description of the remapping ",
    "    methods see SCRIP.",
    "",
    "OPERATORS",
    "    remapbil  Bilinear interpolation",
    "              Performs a bilinear interpolation on all input fields.",
    "              This interpolation method works only on rectangular grids.",
    "    remapbic  Bicubic interpolation",
    "              Performs a bicubic interpolation on all input fields.",
    "              This interpolation method works only on rectangular grids.",
    "    remapcon  Conservative remapping",
    "              Performs a first order conservative remapping on all input fields.",
    "    remapdis  Distance-weighted averaging",
    "              Performs a distance-weighted average of the four nearest neighbor ",
    "              values on all input fields.",
    "",
    "PARAMETER",
    "    grid  STRING  Target grid description file or name",
    "",
    "ENVIRONMENT",
    "    NORMALIZE_OPT",
    "        This variable is used to choose the normalization of the conservative ",
    "        remapping. By default, NORMALIZE_OPT is set to be 'fracarea' and will",
    "        include the destination area fraction in the output weights; other ",
    "        options are 'none' and 'destarea' (for more information see {SCRIP}).",
    NULL
};

static char *GenweightsHelp[] = {
    "NAME",
    "    genbil, genbic, gencon, gendis - Generate SCRIP grid interpolation weights",
    "",
    "SYNOPSIS",
    "    <operator>,grid  ifile ofile",
    "",
    "DESCRIPTION",
    "    Grid interpolation can be a very time consuming process. Especially if the",
    "    data is on an unstructured or on a large grid. In this case the SCRIP ",
    "    interpolation process can be split into two parts. First generation of the",
    "    interpolation weights, this is the most time consuming part. These interpolation ",
    "    weights can be reused for every remapping process. ",
    "    This method works only if all input fields are on the same grid and a possibly",
    "    mask (missing values) does not change. This module contains operators to ",
    "    generate SCRIP interpolation weights of the first input field.",
    "    Each operator is using a different interpolation method.",
    "",
    "OPERATORS",
    "    genbil  Generate bilinear interpolation weights",
    "            Generates bilinear interpolation weights and write the result to a file. ",
    "            This interpolation method works only on rectangular grids.",
    "    genbic  Generate bicubic interpolation weights",
    "            Generates bicubic interpolation weights and write the result to a file.",
    "            This interpolation method works only on rectangular grids.",
    "    gencon  Generate conservative interpolation weights",
    "            Generates first order conservative interpolation weights and",
    "            write the result to a file.",
    "    gendis  Generate distance-weighted averaging weights",
    "            Generates distance-weighted average weights of the four",
    "            nearest neighbor values and write the result to a file.",
    "",
    "PARAMETER",
    "    grid  STRING  Target grid description file or name",
    "",
    "ENVIRONMENT",
    "    NORMALIZE_OPT",
    "        This variable is used to choose the normalization of the conservative ",
    "        interpolation. By default, NORMALIZE_OPT is set to be 'fracarea' and will",
    "        include the destination area fraction in the output weights; other ",
    "        options are 'none' and 'destarea' (for more information see {SCRIP}).",
    NULL
};

static char *RemapHelp[] = {
    "NAME",
    "    remap - SCRIP grid remapping",
    "",
    "SYNOPSIS",
    "    remap,grid,weights  ifile ofile",
    "",
    "DESCRIPTION",
    "    This operator remaps all input fields to a new grid. The remap type and the ",
    "    interpolation weights of one grid are read from a netCDF file. The netCDF ",
    "    file with the weights must follow the SCRIP convention. Normaly these weights ",
    "    come from a previous call to module GENWEIGHTS or was created by the original",
    "    SCRIP package.",
    "",
    "PARAMETER",
    "    grid     STRING  Target grid description file or name",
    "    weights  STRING  Interpolation weights (SCRIP netCDF file)",
    NULL
};

static char *IntgridHelp[] = {
    "NAME",
    "    interpolate, intgridbil - Grid interpolation",
    "",
    "SYNOPSIS",
    "    <operator>,grid  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module contains operators to interpolate all input fields to a new grid.",
    "    All interpolation methods in this module work only on rectangular grids.",
    "",
    "OPERATORS",
    "    interpolate  PINGO grid interpolation",
    "                 This is the grid interpolation from PINGO.",
    "                 For a detailed description of this interpolation method see PINGO.",
    "    intgridbil   Bilinear grid interpolation",
    "                 Performs a bilinear interpolation on all input fields. This implementation",
    "                 is a faster than remapbil. Missing values are not supported yet!",
    "",
    "PARAMETER",
    "    grid  STRING  Target grid description file or name",
    NULL
};

static char *IntvertHelp[] = {
    "NAME",
    "    ml2pl, ml2hl - Vertical interpolation",
    "",
    "SYNOPSIS",
    "    ml2pl,plevels  ifile ofile",
    "    ml2hl,hlevels  ifile ofile",
    "",
    "DESCRIPTION",
    "    Interpolate 3D variables on hybrid model level to pressure or height level.",
    "    The input file must contain the log. surface pressure (LSP/code152) or the ",
    "    surface pressure (APS/code134). To interpolate the temperature,",
    "    the orography (GEOSP/code129) is also needed.",
    "",
    "OPERATORS",
    "    ml2pl  Model to pressure level interpolation",
    "           Interpolates 3D variables on hybrid model level to pressure level.",
    "    ml2hl  Model to height level interpolation",
    "           Interpolates 3D variables on hybrid model level to height level.",
    "           The procedure is the same as for operator mh2pl except that ",
    "           the pressure levels are calculated from the heights by:",
    "           plev = 101325*exp(hlev/-7000)",
    "",
    "PARAMETER",
    "    plevels  FLOAT  Pressure levels in pascal",
    "    hlevels  FLOAT  Height levels in meter (max level: 65535 m)",
    "",
    "ENVIRONMENT",
    "    EXTRAPOLATE",
    "        If set to 1 extrapolate missing values.",
    NULL
};

static char *InttimeHelp[] = {
    "NAME",
    "    inttime - Time interpolation",
    "",
    "SYNOPSIS",
    "    inttime,date,time[,inc]  ifile ofile",
    "",
    "DESCRIPTION",
    "    This operator performs linear interpolation between time steps.",
    "",
    "PARAMETER",
    "    date  STRING  Start date (format YYYY-MM-DD)",
    "    time  STRING  Start time (format hh:mm)",
    "    inc   STRING  Optional increment (minutes, hours or days) [default: 0hour]",
    NULL
};

static char *IntyearHelp[] = {
    "NAME",
    "    intyear - Year interpolation",
    "",
    "SYNOPSIS",
    "    intyear,years  ifile1 ifile2 oprefix",
    "",
    "DESCRIPTION",
    "    This operator performs linear interpolation between two years",
    "    time step by time step. Appends four digits with the year to ",
    "    oprefix to form the output file names.",
    "",
    "PARAMETER",
    "    years  INTEGER  Comma separated list of years",
    NULL
};

static char *SpectralHelp[] = {
    "NAME",
    "    sp2gp, sp2gpl, gp2sp, gp2spl, sp2sp - Spectral transformation",
    "",
    "SYNOPSIS",
    "    sp2gp  ifile ofile",
    "    sp2gpl  ifile ofile",
    "    gp2sp  ifile ofile",
    "    gp2spl  ifile ofile",
    "    sp2sp,trunc  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module transforms fields on gaussian grids to spectral coefficients ",
    "    and vice versa.",
    "",
    "OPERATORS",
    "    sp2gp   Spectral to gridpoint",
    "            Convert all fields with spectral coefficients to regular gaussian",
    "            grid. The number of latitudes of the resulting gaussian grid is ",
    "            calculated from the triangular truncation by:",
    "            ",
    "               nlat = NINT((trunc*3 + 1.)/2.)",
    "    sp2gpl  Spectral to gridpoint linear",
    "            Convert all fields with spectral coefficients to regular gaussian",
    "            grid. The number of latitudes of the resulting Gaussian grid",
    "            is calculated from the triangular truncation by:",
    "            ",
    "               nlat = NINT((trunc*2 + 1.)/2.)",
    "            ",
    "            Use this operator to convert ERA40 data e.g. from TL159 to N80.",
    "    gp2sp   Gridpoint to spectral",
    "            Convert all gaussian gridpoint fields to spectral coefficients.",
    "            The triangular truncation of the resulting spherical harmonics",
    "            is calculated from the number of latitudes by:",
    "            ",
    "               trunc = (nlat*2 - 1) / 3",
    "    gp2spl  Gridpoint to spectral linear",
    "            Convert all gaussian gridpoint fields to spectral coefficients.",
    "            The triangular truncation of the resulting spherical harmonics",
    "            is calculated from the number of latitudes by:",
    "            ",
    "               trunc = (nlat*2 - 1) / 2",
    "            ",
    "            Use this operator to convert ERA40 data e.g. from N80 to TL159",
    "            instead of T106.",
    "    sp2sp   Spectral to spectral",
    "            Change the triangular truncation of all spectral fields.",
    "            The operator performs downward conversion by cutting the resolution.",
    "            Upward conversions are achieved by filling in zeros.",
    "",
    "PARAMETER",
    "    trunc  INTEGER  New spectral resolution",
    NULL
};

static char *WindHelp[] = {
    "NAME",
    "    uv2dv, dv2uv - Wind transformation",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module converts divergence and vorticity to U and V wind and vice versa.",
    "",
    "OPERATORS",
    "    uv2dv  U and V wind to divergence and vorticity",
    "           Calculate spherical harmonic coefficients of divergence and vorticity",
    "           from U and V wind. The divergence and vorticity must have the names sd",
    "           and svo or code numbers 155 and 138.",
    "    dv2uv  Divergence and vorticity to U and V wind",
    "           Calculate U and V wind on a gaussian grid from spherical harmonic ",
    "           coefficients of divergence and vorticity. The U and V wind must have",
    "           the names u and v or the code numbers 131 and 132.",
    NULL
};

static char *InputHelp[] = {
    "NAME",
    "    input, inputsrv, inputext - Formatted input",
    "",
    "SYNOPSIS",
    "    input,grid  ofile",
    "    inputsrv  ofile",
    "    inputext  ofile",
    "",
    "DESCRIPTION",
    "    This modules reads time series of one 2D variable from standard input.",
    "    All input fields must have the same horizontal grid. The format of the ",
    "    input depends on the actual operator.",
    "",
    "OPERATORS",
    "    input     ASCII input",
    "              Read fields with ASCII numbers from standard input and stores them",
    "              in ofile. The numbers that are read are exactly that ones which ",
    "              are written out by output.",
    "    inputsrv  SERVICE input",
    "              Read fields with ASCII numbers from standard input and stores them ",
    "              in ofile. Each field must have a header of 8 integers (SERVICE likely).",
    "              The numbers that are read are exactly that ones which are written ",
    "              out by outputsrv.",
    "    inputext  EXTRA input",
    "              Read fields with ASCII numbers from standard input and stores them ",
    "              in ofile. Each field with a header of 4 integers (EXTRA likely).",
    "              The numbers that are read are exactly that ones which are written ",
    "              out by outputext.",
    "",
    "PARAMETER",
    "    grid  STRING  Grid description file or name",
    NULL
};

static char *OutputHelp[] = {
    "NAME",
    "    output, outputf, outputint, outputsrv, outputext - Formatted output",
    "",
    "SYNOPSIS",
    "    output  ifiles",
    "    outputf,format,nelem  ifiles",
    "    outputint  ifiles",
    "    outputsrv  ifiles",
    "    outputext  ifiles",
    "",
    "DESCRIPTION",
    "    This modules prints all values of all input datasets to standard output.",
    "    All input fields must have the same horizontal grid. The format of the ",
    "    output depends on the actual operator.",
    "",
    "OPERATORS",
    "    output     ASCII output",
    "               Prints all values to standard output.",
    "               Each row has 6 elements with the C-style format \"%13.6g\".",
    "    outputf    Formatted output",
    "               Prints all values to standard output.",
    "               The format and number of elements for each row can be specified by the parameters.",
    "    outputint  Integer output",
    "               Prints all values rounded to the nearest interger to standard output.",
    "    outputsrv  SERVICE output",
    "               Prints all values to standard output.",
    "               Each field with a header of 8 integers (SERVICE likely).",
    "    outputext  EXTRA output",
    "               Prints all values to standard output.",
    "               Each field with a header of 4 integers (EXTRA likely).",
    "",
    "PARAMETER",
    "    format  STRING  C-style format for one element (e.g. \%13.6g)",
    "    nelem   INTEGER Number of elements for each row",
    NULL
};

static char *TimsortHelp[] = {
    "NAME",
    "    timsort - Timsort",
    "",
    "SYNOPSIS",
    "    timsort  ifile ofile",
    "",
    "DESCRIPTION",
    "    Sorts for every field position the elements in ascending order over all time steps.",
    "    After sorting it is:",
    "    ",
    "    o(t_1,x) < o(t_2,x)      forall (t_1<t_2),x",
    NULL
};

static char *VargenHelp[] = {
    "NAME",
    "    const, random - Generate a field",
    "",
    "SYNOPSIS",
    "    const,const,grid  ofile",
    "    random,grid  ofile",
    "",
    "DESCRIPTION",
    "    Generates a dataset with one field. The size of the field",
    "    is specified by the user given grid description.",
    "    According to the actual operator all field elements",
    "    are constant or filled with random numbers.",
    "",
    "OPERATORS",
    "    const   Create a constant field",
    "            Creates a constant field. All field elements of the grid",
    "            have the same value.",
    "    random  Create a field with random values",
    "            Creates a field with rectangularly distrubuted random numbers in the interval [0,1].",
    "",
    "PARAMETER",
    "    const  FLOAT   Constant",
    "    grid   STRING  Target grid description file or name",
    NULL
};

static char *VardupHelp[] = {
    "NAME",
    "    vardup, varmul - Variable duplication",
    "",
    "SYNOPSIS",
    "    vardup  ifile ofile",
    "    varmul,nmul  ifile ofile",
    "",
    "DESCRIPTION",
    "    Duplicates all variables of a dataset.",
    "",
    "OPERATORS",
    "    vardup  Duplicate variables",
    "            Duplicates all variables.",
    "    varmul  Multiply variables",
    "            Multiplies all variables.",
    "",
    "PARAMETER",
    "    nmul  INTEGER  Number of multiplications",
    NULL
};

static char *GradsdesHelp[] = {
    "NAME",
    "    gradsdes1, gradsdes2 - GrADS data descriptor file",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "    Creates a GrADS data descriptor file. Supported file formats are GRIB,",
    "    SERVICE, EXTRA and IEG. For GRIB files the GrADS map file is also ",
    "    generated. For SERVICE and EXTRA files the grid must be specified with",
    "    the CDO option '-g <grid>'. This module takes ifile in order to create ",
    "    filenames for the descriptor (ifile.ctl) and the map (ifile.gmp) file.",
    "    \"gradsdes\" is an alias for gradsdes2.",
    "",
    "OPERATORS",
    "    gradsdes1  GrADS data descriptor file (version 1 GRIB map)",
    "               Creates a GrADS data descriptor file. Generated a machine",
    "               specific version 1 GrADS map file for GRIB datasets.",
    "    gradsdes2  GrADS data descriptor file (version 2 GRIB map)",
    "               Creates a GrADS data descriptor file. Generated a machine ",
    "               independent version 2 GrADS map file for GRIB datasets.",
    "               This map file can be used only with GrADS version 1.8 or newer. ",
    NULL
};

static char *RotuvHelp[] = {
    "NAME",
    "    rotuvb - Rotation",
    "",
    "SYNOPSIS",
    "    rotuvb,u,v,...  ifile ofile",
    "",
    "DESCRIPTION",
    "    This is a special operator for datsets with wind components on an rotated grid, ",
    "    e.g. data from the regional model REMO. It performs a backward transformation of ",
    "    velocity components U and V from an rotated spherical system to a geographical system.",
    "",
    "PARAMETER",
    "    u,v,...  STRING  Pairs of zonal and meridional velocity components (use variable names or code numbers)",
    NULL
};

static char *MastrfuHelp[] = {
    "NAME",
    "    mastrfu - Mass stream function",
    "",
    "SYNOPSIS",
    "    mastrfu  ifile ofile",
    "",
    "DESCRIPTION",
    "    This is a special operator for the post processing of the atmospheric ",
    "    general circulation model ECHAM. It computes the mass stream function ",
    "    (code number 272). The input dataset must be a zonal mean of v-velocity",
    "    (code number 132) on pressure levels.",
    NULL
};
