
static char *InfoHelp[] = {
    "NAME",
    "    info, infov, map - Info and simple statistics",
    "",
    "SYNOPSIS",
    "    <operator>  ifiles",
    "",
    "DESCRIPTION",
    "    This module writes information about the structure and ",
    "    contents of all input datasets to standard output.",
    "    The information displayed depends on the actual operator name.",
    "",
    "OPERATORS",
    "    info   Dataset information",
    "           Prints information and simple statistics for each field of all input datasets.",
    "           For each field the operator print in one line the:",
    "           - Date and Time",
    "           - Code number and Level",
    "           - Size of the grid and number of Missing values",
    "           - Minimum, Mean and Maximum \\",
    "           The mean value is computed without the use of area weights!",
    "    infov  Dataset information",
    "           The same as operator {\\bf info} but using the name instead of the code number",
    "           to identify the variables.",
    "    map    Dataset information and simple map",
    "           Prints information, simple statistic and a map for each field of all input datasets.",
    "           The map will be printed only for fields on a rectangular grid.",
    NULL
};

static char *SinfoHelp[] = {
    "NAME",
    "    sinfo, sinfov, sinfop - Short info",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "    This module writes information about the structure",
    "    of all input datasets to standard output.",
    "    The information displayed depends on the actual operator name.",
    "",
    "OPERATORS",
    "    sinfo   Short dataset information",
    "            Prints short information for each variable of a dataset.",
    "            For each variable the operator print in one line the:",
    "            - institute and source",
    "            - parameter table and code number",
    "            - horizontal grid size and number",
    "            - number of vertical levels and zaxis number",
    "    sinfov  Short dataset information",
    "            The same as operator {\\bf sinfo} but using the name instead of the code number",
    "            and parameter table to identify the variables.",
    NULL
};

static char *DiffHelp[] = {
    "NAME",
    "    diff, diffv - Compare two datasets field by field",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2",
    "",
    "DESCRIPTION",
    "    Compares the contents of two datasets.",
    "    The input datasets must have the same structure and the fields must have ",
    "    the same header information and dimensions.",
    "",
    "OPERATORS",
    "    diff   Compare two datasets",
    "           Print statistics over differences of two datasets.",
    "           For each pair of fields the operator print in one line the:",
    "           - date and time",
    "           - code number and level",
    "           - size of the grid and number of missing values",
    "           - occurrence of coefficient pairs with different signs",
    "           - occurrence of zero values",
    "           - maxima of absolute difference of coefficient pairs",
    "           - maxima of relative difference of non-zero coefficient pairs with equal signs",
    "    diffv  Compare two datasets",
    "           The same as operator diff. Using the name instead of the code number",
    "           to identify the variable.",
    NULL
};

static char *NinfoHelp[] = {
    "NAME",
    "    ncode, nvar, nlevel, nyear, nmon, ndate, ntime - Print numbers",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    ncode   Number of codes",
    "            Prints the number of different codes.",
    "    nvar    Number of variables",
    "            Prints the number of different variables.",
    "    nlevel  Number of levels",
    "            Prints the number of levels for each variable.",
    "    nyear   Number of years",
    "            Prints the number of different years.",
    "    nmon    Number of months",
    "            Prints the number of different combinations of years and months.",
    "    ndate   Number of dates",
    "            Prints the number of different dates.",
    "    ntime   Number of timesteps",
    "            Prints the number of timesteps.",
    NULL
};

static char *ShowinfoHelp[] = {
    "NAME",
    "    showcode, showvar, showlevel, showyear, showmon, showdate, showtime - Show",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    showcode   Show codes",
    "               Prints the code of all different variables.",
    "    showvar    Show variable names",
    "               Print all different variable names.",
    "    showlevel  Show levels",
    "               Prints all levels for each variable.",
    "    showyear   Show years",
    "               Prints all different years.",
    "    showmon    Show months",
    "               Prints all different months.",
    "    showdate   Show dates",
    "               Prints all different dates.",
    "    showtime   Show timesteps",
    "               Prints all timesteps.",
    NULL
};

static char *FiledesHelp[] = {
    "NAME",
    "    vardes, griddes, vct - Dataset description",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    vardes   Variable description",
    "             Prints a table with a description of all variables.",
    "             For each variable the operator print in one line the",
    "             code, name, description and units.",
    "    griddes  Grid description",
    "             Prints the description of all grids in a file.",
    "    vct      Vertical coordinate table",
    "             Prints the vertical coordinate table.",
    NULL
};

static char *CopyHelp[] = {
    "NAME",
    "    copy, cat - Copy datasets",
    "",
    "SYNOPSIS",
    "    <operator>  ifiles ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    copy  Copy datasets",
    "          Copies all input datasets to ofile. Each input dataset must have the ",
    "          same variables with complete timesteps.",
    "    cat   Concatenate datasets",
    "          Concatenates all input datasets and add the result at the end ",
    "          of ofile. If ofile does not exist it will be created.",
    "          Each input dataset must have the same variables with complete timesteps.",
    NULL
};

static char *ReplaceHelp[] = {
    "NAME",
    "    replace - Replace variables",
    "",
    "SYNOPSIS",
    "    replace  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    Replaces all variables of ifile2 in ifile1 and write the result to ofile.",
    "    Both input datasets must have the same number of timesteps.",
    NULL
};

static char *MergeHelp[] = {
    "NAME",
    "    merge, mergetime - Merge datasets",
    "",
    "SYNOPSIS",
    "    <operator>  ifiles ofile",
    "",
    "DESCRIPTION",
    "    This module reads datasets from several input files,",
    "    merges them and writes the resulting dataset to ofile.",
    "",
    "OPERATORS",
    "    merge      Merge datasets with different fields",
    "               Merges time series from several input datasets.",
    "               The number of fields per time step written to ofile",
    "               is the sum of the field numbers per time step in all input datasets.",
    "               The time series on all input datasets must have different fields",
    "               and the same number of time steps.",
    "    mergetime  Merge datasets sorted by date and time",
    "               Merges all time steps of all input files sorted by date and time.",
    "               After this operation every input time step is in ofile and",
    "               all time steps are sorted by date and time.",
    "               Each input file must have the same variables.",
    NULL
};

static char *SplitHelp[] = {
    "NAME",
    "    splitcode, splitvar, splitlevel, splitgrid, splitzaxis, splitrec - Split a dataset",
    "",
    "SYNOPSIS",
    "    <operator>  ifile oprefix",
    "",
    "DESCRIPTION",
    "    This module splits a dataset to several files with names",
    "    formed from the field header information and oprefix.",
    "",
    "OPERATORS",
    "    splitcode   Split codes",
    "                Splits a dataset into pieces, one for each different code.",
    "                Appends three digits with the code number to oprefix to ",
    "                form the output file names.",
    "    splitvar    Split variables",
    "                Splits a dataset into pieces, one for each different variable.",
    "                Appends a string with the variable name to oprefix to ",
    "                form the output file names.",
    "    splitlevel  Split levels",
    "                Splits a dataset into pieces, one for each different level.",
    "                Appends six digits with the level to oprefix to ",
    "                form the output file names.",
    "    splitgrid   Split grids",
    "                Splits a dataset into pieces, one for each different grid.",
    "                Appends two digits with the grid number to oprefix to ",
    "                form the output file names.",
    "    splitzaxis  Split zaxis",
    "                Splits a dataset into pieces, one for each different zaxis.",
    "                Appends two digits with the zaxis number to oprefix to ",
    "                form the output file names.",
    "    splitrec    Split records",
    "                Splits a dataset into pieces, one for each record.",
    "                Appends five digits with the record number to oprefix to ",
    "                form the output file names.",
    NULL
};

static char *SplittimeHelp[] = {
    "NAME",
    "    splithour, splitday, splitmon, splitseas, splityear - Split time steps of a dataset",
    "",
    "SYNOPSIS",
    "    <operator>  ifile oprefix",
    "",
    "DESCRIPTION",
    "    This module splits time steps of a dataset to several files with names",
    "    formed from the field header information and oprefix.",
    "",
    "OPERATORS",
    "    splithour  Split hours",
    "               Splits a file into pieces, one for each different hour.",
    "               Appends two digits with the hour to oprefix to ",
    "               form the output file names.",
    "    splitday   Split days",
    "               Splits a file into pieces, one for each different day.",
    "               Appends two digits with the day to oprefix to ",
    "               form the output file names.",
    "    splitmon   Split months",
    "               Splits a file into pieces, one for each different month.",
    "               Appends two digits with the month to oprefix to ",
    "               form the output file names.",
    "    splitseas  Split seasons",
    "               Splits a file into pieces, one for each different season.",
    "               Appends tree characters with the season to oprefix to ",
    "               form the output file names.",
    "    splityear  Split years",
    "               Splits a file into pieces, one for each different year.",
    "               Appends four digits with the year to oprefix to ",
    "               form the output file names.",
    NULL
};

static char *SelectHelp[] = {
    "NAME",
    "    selcode, delcode, selvar, delvar, sellevel, selgrid, selgridname, selzaxis, selzaxisname, seltabnum - Select fields",
    "",
    "SYNOPSIS",
    "    selcode,codes  ifile ofile",
    "    delcode,codes  ifile ofile",
    "    selvar,vars  ifile ofile",
    "    delvar,vars  ifile ofile",
    "    sellevel,levels  ifile ofile",
    "    selgrid,grids  ifile ofile",
    "    selgridname,gridnames  ifile ofile",
    "    selzaxis,zaxis  ifile ofile",
    "    selzaxisname,zaxisnames  ifile ofile",
    "    seltabnum,tabnum  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module selects some fields from ifile and write the",
    "    result to ofile.",
    "    Which fields are selected depents on the operator name.",
    "",
    "OPERATORS",
    "    selcode       Select codes",
    "                  Selects all fields with a code in a user given list.",
    "    delcode       Delete codes",
    "                  Deletes all fields with a code in a user given list.",
    "    selvar        Select variables",
    "                  Selects all fields with a variable name in a user given list.",
    "    delvar        Delete variables",
    "                  Deletes all fields with a variable name in a user given list.",
    "    sellevel      Select levels",
    "                  Selects all fields with a level in a user given list.",
    "    selgrid       Select grids",
    "                  Selects all fields with a grid in a user given list.",
    "    selgridname   Select grid by name",
    "                  Selects all fields with a grid name in a user given list.",
    "    selzaxis      Select zaxis",
    "                  Selects all fields with a zaxis in a user given list.",
    "    selzaxisname  Select zaxis by name",
    "                  Selects all fields with a zaxis name in a user given list.",
    "    seltabnum     Select parameter table number",
    "                  Selects all fields with a table number in a user given list.",
    "",
    "PARAMETER",
    "    codes       INTEGER  Comma separated list of codes",
    "    vars        STRING  Comma separated list of variable names",
    "    levels      FLOAT  Comma separated list of levels",
    "    grids       INTEGER  Comma separated list of grid numbers",
    "    gridnames   STRING  Comma separated list of grid names",
    "    zaxis       INTEGER  Comma separated list of zaxis numbers",
    "    zaxisnames  STRING  Comma separated list of zaxis names",
    "    tabnum      INTEGER  Comma separated list of table numbers",
    NULL
};

static char *SeltimeHelp[] = {
    "NAME",
    "    seltimestep, seltime, selhour, selday, selmon, selyear, selseas, seldate - Select time steps",
    "",
    "SYNOPSIS",
    "    seltimestep,timesteps  ifile ofile",
    "    seltime,times  ifile ofile",
    "    selhour,hours  ifile ofile",
    "    selday,days  ifile ofile",
    "    selmon,months  ifile ofile",
    "    selyear,years  ifile ofile",
    "    selseas,seasons  ifile ofile",
    "    seldate,date1[,date2]  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module selects some time steps from ifile and write the",
    "    result to ofile.",
    "    Which time steps are selected depents on the operator name.",
    "",
    "OPERATORS",
    "    seltimestep  Select timesteps",
    "                 Selects all timesteps with a timestep in a user given list.",
    "    seltime      Select times",
    "                 Selects all timesteps with a time in a user given list.",
    "    selhour      Select hours",
    "                 Selects all timesteps with a hour in a user given list.",
    "    selday       Select days",
    "                 Selects all timesteps with a day in a user given list.",
    "    selmon       Select months",
    "                 Selects all timesteps with a month in a user given list.",
    "    selyear      Select years",
    "                 Selects all timesteps with a year in a user given list.",
    "    selseas      Select seasons",
    "                 Selects all timesteps with a month of a season in a user given list.",
    "    seldate      Select dates",
    "                 Selects all timesteps with a date in a user given range.",
    "",
    "PARAMETER",
    "    timesteps  INTEGER  Comma separated list of timesteps",
    "    times      STRING  Comma separated list of times (format HH:MM)",
    "    hours      INTEGER  Comma separated list of hours",
    "    days       INTEGER  Comma separated list of days",
    "    months     INTEGER  Comma separated list of months",
    "    years      INTEGER  Comma separated list of years",
    "    seasons    STRING   Comma separated list of seasons (DJF, MAM, JJA, SON)",
    "    date1      STRING  Start date (format YYYY-MM-DD)",
    "    date2      STRING  End date (format YYYY-MM-DD)",
    NULL
};

static char *SelrecHelp[] = {
    "NAME",
    "    selrec - Selrec",
    "",
    "SYNOPSIS",
    "    selrec,records  ifile ofile",
    "",
    "DESCRIPTION",
    "    Selects all fields with a record number in a user given list.",
    "    This operator does not work on netCDF data!",
    "",
    "PARAMETER",
    "    records  INTEGER  Comma separated list of records",
    NULL
};

static char *SelboxHelp[] = {
    "NAME",
    "    sellonlatbox, selindexbox - Select a box of a field",
    "",
    "SYNOPSIS",
    "    sellonlatbox,lon1,lon2,lat1,lat2  ifile ofile",
    "    selindexbox,idx1,idx2,idy1,idy2  ifile ofile",
    "",
    "DESCRIPTION",
    "    Selects a box of the rectangular understood field.",
    "",
    "OPERATORS",
    "    sellonlatbox  Select lon/lat box",
    "                  Selects a longitude/latitude box. The user has to give the ",
    "                  longitudes and latitudes of the edges of the box.",
    "    selindexbox   Select index box",
    "                  Selects an index box. The user has to give the indexes of the ",
    "                  edges of the box. The index of the left edge may be greater ",
    "                  then that of the right edge.",
    "",
    "PARAMETER",
    "    lon1  FLOAT  Western longitude",
    "    lon2  FLOAT  Eastern longitude",
    "    lat1  FLOAT  Southern or northern latitude",
    "    lat2  FLOAT  Northern or southern latitude",
    "    idx1  INTEGER  Index of first longitude",
    "    idx2  INTEGER  Index of last longitude",
    "    idy1  INTEGER  Index of first latitude",
    "    idy2  INTEGER  Index of last latitude",
    NULL
};

static char *SetHelp[] = {
    "NAME",
    "    setpartab, setcode, setvar, setlevel - Set",
    "",
    "SYNOPSIS",
    "    setpartab,table  ifile ofile",
    "    setcode,code  ifile ofile",
    "    setvar,name  ifile ofile",
    "    setlevel,level  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    setpartab  Set parameter table",
    "               Sets the parameter table for all variables.",
    "    setcode    Set code",
    "               Sets the code for all variables to the same given value.",
    "    setvar     Set variable name",
    "               Sets the name of the first variable.",
    "    setlevel   Set level",
    "               Sets the first level of all variables.",
    "",
    "PARAMETER",
    "    table  STRING   Parameter table file or name",
    "    code   INTEGER  Code number",
    "    name   STRING   Variable name",
    "    level  FLOAT    New level",
    NULL
};

static char *SettimeHelp[] = {
    "NAME",
    "    setdate, settime, setday, setmon, setyear, settunits, settaxis, setreftime, setcalendar, shifttime - Set time",
    "",
    "SYNOPSIS",
    "    setdate,date  ifile ofile",
    "    settime,time  ifile ofile",
    "    setday,day  ifile ofile",
    "    setmon,month  ifile ofile",
    "    setyear,year  ifile ofile",
    "    settunits,units  ifile ofile",
    "    settaxis,date,time[,inc]  ifile ofile",
    "    setreftime,date,time  ifile ofile",
    "    setcalendar,calendar  ifile ofile",
    "    shifttime,sval  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    setdate      Set date",
    "                 Sets the date in every timestep to the same given value.",
    "    settime      Set time",
    "                 Sets the time in every timestep to the same given value.",
    "    setday       Set day",
    "                 Sets the day in every timestep to the same given value.",
    "    setmon       Set month",
    "                 Sets the month in every timestep to the same given value.",
    "    setyear      Set year",
    "                 Sets the year in every timestep to the same given value.",
    "    settunits    Set time units",
    "                 Sets the base units of an relative time axis.",
    "    settaxis     Set time axis",
    "                 Sets the time axis.",
    "    setreftime   Set reference time",
    "                 Sets the reference time of an relative time axis.",
    "    setcalendar  Set calendar",
    "                 Sets the calendar of an relative time axis.",
    "    shifttime    Shift timesteps",
    "                 Shifts all timesteps by the parameter sval.",
    "",
    "PARAMETER",
    "    day       INTEGER  Value of the new day",
    "    month     INTEGER  Value of the new month",
    "    year      INTEGER  Value of the new year",
    "    units     STRING  Base units of the time axis (minutes, hours, days, months, years).",
    "    date      STRING  Date (format YYYY-MM-DD)",
    "    time      STRING  Time (format HH:MM)",
    "    inc       STRING  Optional increment (e.g. 12hour) [default: 0hour]",
    "    calendar  STRING  Calendar (standard, 360days, 365days, 366days)",
    "    sval      STRING   Shift value (e.g. -3hour)",
    NULL
};

static char *ChangeHelp[] = {
    "NAME",
    "    chcode, chvar, chlevel, chlevelc, chlevelv - Change header info",
    "",
    "SYNOPSIS",
    "    chcode,oldcode,newcode[,...]  ifile ofile",
    "    chvar,ovar,nvar,...  ifile ofile",
    "    chlevel,oldlev,newlev,...  ifile ofile",
    "    chlevelc,code,oldlev,newlev  ifile ofile",
    "    chlevelv,var,oldlev,newlev  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module reads fields from ifile, changes some header values",
    "    and writes the results to ofile.",
    "",
    "OPERATORS",
    "    chcode    Change code",
    "              Changes some user given code numbers to new user given values.",
    "    chvar     Change variable name",
    "              Changes some user given variable names to new user given names.",
    "    chlevel   Change level",
    "              Changes some user given levels to new user given values.",
    "    chlevelc  Change level of one code",
    "              Changes one level of a user given code number.",
    "    chlevelv  Change level of one variable",
    "              Changes one level of a user given variable.",
    "",
    "PARAMETER",
    "    code                 INTEGER Code number",
    "    oldcode,newcode,...  INTEGER  Pairs of old and new code numbers",
    "    var                  STRING Variable name",
    "    ovar,nvar,...        STRING  Pairs of old and new variable names",
    "    oldlev               FLOAT  Old level",
    "    newlev               FLOAT  New level",
    "    oldlev,newlev,...    FLOAT  Pairs of old and new levels",
    NULL
};

static char *SetgridHelp[] = {
    "NAME",
    "    setgrid, setgridtype - Set grid type",
    "",
    "SYNOPSIS",
    "    setgrid,grid  ifile ofile",
    "    setgridtype,gridtype  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    setgrid      Set grid",
    "                 Sets the grid information for all variables.",
    "    setgridtype  Set grid type",
    "                 Sets the grid type for all grids to a user given value.",
    "",
    "PARAMETER",
    "    grid      STRING  Grid description file or name of the target grid",
    "    gridtype  STRING  New grid type (curvilinear or cell)",
    NULL
};

static char *SetzaxisHelp[] = {
    "NAME",
    "    setzaxis - Set zaxis type",
    "",
    "SYNOPSIS",
    "    setzaxis,zaxis  ifile ofile",
    "",
    "DESCRIPTION",
    "    Sets the zaxis information for all variables.",
    "",
    "PARAMETER",
    "    zaxis  STRING  Zaxis description file or name of the target zaxis",
    NULL
};

static char *SetgattHelp[] = {
    "NAME",
    "    setgatt, setgatts - Set global attribute",
    "",
    "SYNOPSIS",
    "    setgatt,attname,attstring  ifile ofile",
    "    setgatts,attfile  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    setgatt   Set global attribute",
    "              Sets one user defined global text attribute.",
    "    setgatts  Set global attributes",
    "              Sets user defined global text attributes. The name and text",
    "              of the global attributes are read from a file.",
    "",
    "PARAMETER",
    "    attname,attstring  STRING  Name and text of the global attribute",
    "    attfile            STRING  File name which contains global attributes",
    NULL
};

static char *InvertHelp[] = {
    "NAME",
    "    invertlat, invertlon, invertlatdes, invertlondes, invertlatdata, invertlondata - Invert",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    invertlat      Invert latitude",
    "                   Invert the latitude of a field.",
    "    invertlon      Invert longitude",
    "                   Invert the longitude of a field.",
    "    invertlatdes   Invert latitude description",
    "                   Invert only the latitude description of a field.",
    "    invertlondes   Invert longitude description",
    "                   Invert only the longitude description of a field.",
    "    invertlatdata  Invert latitude data",
    "                   Invert only the latitude data of a field.",
    "    invertlondata  Invert longitude data",
    "                   Invert only the longitude data of a field.",
    NULL
};

static char *MaskboxHelp[] = {
    "NAME",
    "    masklonlatbox, maskindexbox - Masks a box",
    "",
    "SYNOPSIS",
    "    masklonlatbox,lon1,lon2,lat1,lat2  ifile ofile",
    "    maskindexbox,idx1,idx2,idy1,idy2  ifile ofile",
    "",
    "DESCRIPTION",
    "    Masks a box of the rectangular understood field. The elements inside ",
    "    the box are untouched, the elements outside are set to missing value.",
    "",
    "OPERATORS",
    "    masklonlatbox  Mask lon/lat box",
    "                   Masks a longitude/latitude box. The user has to give the ",
    "                   longitudes and latitudes of the edges of the box.",
    "    maskindexbox   Mask index box",
    "                   Masks an index box. The user has to give the indexes of the ",
    "                   edges of the box. The index of the left edge may be greater ",
    "                   then that of the right edge.",
    "",
    "PARAMETER",
    "    lon1  FLOAT  Western longitude",
    "    lon2  FLOAT  Eastern longitude",
    "    lat1  FLOAT  Southern or northern latitude",
    "    lat2  FLOAT  Northern or southern latitude",
    "    idx1  INTEGER  Index of first longitude",
    "    idx2  INTEGER  Index of last longitude",
    "    idy1  INTEGER  Index of first latitude",
    "    idy2  INTEGER  Index of last latitude",
    NULL
};

static char *EnlargeHelp[] = {
    "NAME",
    "    enlarge - Enlarge fields",
    "",
    "SYNOPSIS",
    "    enlarge,grid  ifile ofile",
    "",
    "DESCRIPTION",
    "    Enlarge all fields of ifile to a user given grid.",
    "    Normally only the last feld element is used for the enlargement.  ",
    "    If however the input and output grid are rectangular,",
    "    a zonal or meridional enlargement is possible.",
    "    Zonal enlargement takes place, if the xsize of the",
    "    input field is 1 and the ysize of both grids are the same.",
    "    For meridional enlargement the ysize must be 1 and",
    "    the xsize of both grids must have the same size.",
    "",
    "PARAMETER",
    "    grid  STRING  Grid description file or name",
    NULL
};

static char *SetmissHelp[] = {
    "NAME",
    "    setmissval, setctomiss, setmisstoc, setrtomiss - Set missing value",
    "",
    "SYNOPSIS",
    "    setmissval,miss  ifile ofile",
    "    setctomiss,c  ifile ofile",
    "    setmisstoc,c  ifile ofile",
    "    setrtomiss,rmin,rmax  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    setmissval  Set a new missing value",
    "                         / miss   if i(t,x) EQ miss",
    "                o(t,x) = ",
    "                         \\ i(t,x) if i(t,x) NE miss",
    "    setctomiss  Set constant to missing value",
    "                         / miss   if i(t,x) EQ c",
    "                o(t,x) = ",
    "                         \\ i(t,x) if i(t,x) NE c",
    "    setmisstoc  Set missing value to constant",
    "                         / c      if i(t,x) EQ miss",
    "                o(t,x) = ",
    "                         \\ i(t,x) if i(t,x) NE miss",
    "    setrtomiss  Set range to missing value",
    "                         / miss   if i(t,x) GE rmin AND i(t,x) LE rmax",
    "                o(t,x) = ",
    "                         \\ i(t,x) if i(t,x) LT rmin AND i(t,x) GT rmax",
    "",
    "PARAMETER",
    "    miss  FLOAT  New missing value",
    "    c     FLOAT  Constant",
    "    rmin  FLOAT  Lower bound",
    "    rmax  FLOAT  Upper bound",
    NULL
};

static char *ExprHelp[] = {
    "NAME",
    "    expr, exprf - Evaluate expressions",
    "",
    "SYNOPSIS",
    "    expr,instr  ifile ofile",
    "    exprf,filename  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module arithmetically processes every timestep of ifile.",
    "",
    "OPERATORS",
    "    expr   Evaluate expressions",
    "           The processing instructions are read from the parameter.",
    "           Each individual assignment statement must end with a semi-colon.",
    "    exprf  Evaluate expressions from script file",
    "           Contrary to expr the processing instructions are read from a file.",
    "",
    "PARAMETER",
    "    instr  STRING  Processing instructions",
    NULL
};

static char *MathHelp[] = {
    "NAME",
    "    abs, sqr, sqrt, exp, log, log10, sin, cos, tan, asin, acos, atan - Mathematical functions",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    abs    Absolute value",
    "           Calculates the absolute value of i(t,x).",
    "    sqr    Square",
    "           Calculates the value of i(t,x) raised to the power of 2.",
    "    sqrt   Square root",
    "           Calculates the non-negative square root of i(t,x).",
    "    exp    Exp",
    "           Calculates e (the base of natural logarithms) raised to the power of i(t,x).",
    "    log    Logarithm",
    "           Calculates the natural logarithm of i(t,x).",
    "    log10  Logarithm base 10",
    "           Calculates the base-10 logarithm of i(t,x).",
    "    sin    Sine",
    "           Calculates the sine of i(t,x), where i(t,x) is given in radians.",
    "    cos    Cosine",
    "           Calculates the cosine of i(t,x), where i(t,x) is given in radians.",
    "    tan    Tangent",
    "           Calculates the tangent of i(t,x), where i(t,x) is given in radians.",
    "    asin   Arcus sine",
    "           Calculates the arcus sine of i(t,x); that is the value whose sine is i(t,x).",
    "    acos   Arcus cosine",
    "           Calculates the arcus cosine of i(t,x); that is the value whose cosine is i(t,x).",
    "    atan   Arcus tangent",
    "           Calculates the arcus tangent of i(t,x); that is the value whose tangent is i(t,x).",
    NULL
};

static char *ArithcHelp[] = {
    "NAME",
    "    addc, subc, mulc, divc - Arithmetic with a constant",
    "",
    "SYNOPSIS",
    "    <operator>,c  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module performs simple arithmetic with a dataset and a constant.",
    "    The header and date information in ofile is the same as in ifile.",
    "",
    "OPERATORS",
    "    addc  Add by constant",
    "          o(t,x) = i(t,x) + c",
    "    subc  Subtract by constant",
    "          o(t,x) = i(t,x) - c",
    "    mulc  Multiply by constant",
    "          o(t,x) = i(t,x) * c",
    "    divc  Divide by constant",
    "          o(t,x) = i(t,x) / c",
    "",
    "PARAMETER",
    "    c  FLOAT  Constant",
    NULL
};

static char *ArithHelp[] = {
    "NAME",
    "    add, sub, mul, div, min, max - Arithmetic on two datasets",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    This module performs simple arithmetic of two datasets.",
    "    The header and date information in ofile is the same as in ifile1.",
    "",
    "OPERATORS",
    "    add  Add two fields",
    "         o(t,x) = i_1(t,x) + i_2(t,x)",
    "    sub  Subtract two fields",
    "         o(t,x) = i_1(t,x) - i_2(t,x)",
    "    mul  Multiply two fields",
    "         o(t,x) = i_1(t,x) * i_2(t,x)",
    "    div  Divide two fields",
    "         o(t,x) = i_1(t,x) / i_2(t,x)",
    "    min  Minimum of two fields",
    "         o(t,x) = MIN(i_1(t,x), i_2(t,x))",
    "    max  Maximum of two fields",
    "         o(t,x) = MAX(i_1(t,x), i_2(t,x))",
    NULL
};

static char *YmonarithHelp[] = {
    "NAME",
    "    ymonadd, ymonsub, ymonmul, ymondiv - Multi-year monthly arithmetic",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    This module performs simple arithmetic of a time series and a",
    "    time step with same month of year.",
    "    For each field in ifile1 the corresponding field of the time step in",
    "    ifile2 with the same month of year is used.",
    "    The header information in ifile1 must be the same as in ifile2.",
    "    Usually ifile2 is generated by a call of module YMONSTAT.",
    "",
    "OPERATORS",
    "    ymonadd  Add multi-year monthly time averages",
    "             Adds a time series and a multi-year monthly time averages.",
    "    ymonsub  Subtract multi-year monthly time averages",
    "             Subtracts a time series and a multi-year monthly time averages.",
    "    ymonmul  Multiply multi-year monthly time averages",
    "             Multiplies a time series and a multi-year monthly time averages.",
    "    ymondiv  Divide multi-year monthly time averages",
    "             Divides a time series and a multi-year monthly time averages.",
    NULL
};

static char *ArithdaysHelp[] = {
    "NAME",
    "    muldpm, divdpm, muldpy, divdpy - Arithmetic with days",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    muldpm  Multiply with days per month",
    "            o(t,x) = i(t,x) * days\\_per\\_month",
    "    divdpm  Divide by days per month",
    "            o(t,x) = i(t,x) / days\\_per\\_month",
    "    muldpy  Multiply with days per year",
    "            o(t,x) = i(t,x) * days\\_per\\_year",
    "    divdpy  Divide by days per year",
    "            o(t,x) = i(t,x) / days\\_per\\_year",
    NULL
};

static char *CompHelp[] = {
    "NAME",
    "    eq, ne, le, lt, ge, gt - Comparison of two fields",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    eq  Equal",
    "                  /   1   if i_1(t,x) EQ i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) NE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    ne  Not equal",
    "                  /   1   if i_1(t,x) NE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) EQ i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    le  Less equal",
    "                  /   1   if i_1(t,x) LE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) GT i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    lt  Less than",
    "                  /   1   if i_1(t,x) LT i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) GE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    ge  Greater equal",
    "                  /   1   if i_1(t,x) GE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) LT i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    "    gt  Greater than",
    "                  /   1   if i_1(t,x) GT i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "        o(t,x) = <    0   if i_1(t,x) LE i_2(t,x)  AND  i_1(t,x),i_2(t,x) NE miss",
    "                  \\  miss if i_1(t,x) EQ miss      OR   i_2(t,x) EQ miss",
    NULL
};

static char *CompcHelp[] = {
    "NAME",
    "    eqc, nec, lec, ltc, gec, gtc - Comparison of a field with a constant",
    "",
    "SYNOPSIS",
    "    <operator>,c  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    eqc  Equal constant",
    "                   /   1   if i(t,x) EQ c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) NE c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    nec  Not equal constant",
    "                   /   1   if i(t,x) NE c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) EQ c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    lec  Less equal constant",
    "                   /   1   if i(t,x) LE c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) GT c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    ltc  Less then constant",
    "                   /   1   if i(t,x) LT c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) GE c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    gec  Greater equal constant",
    "                   /   1   if i(t,x) GE c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) LT c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "    gtc  Greater then constant",
    "                   /   1   if i(t,x) GT c     AND  i(t,x),c NE miss",
    "         o(t,x) = <    0   if i(t,x) LE c     AND  i(t,x),c NE miss",
    "                   \\  miss if i(t,x) EQ miss  OR   c EQ miss",
    "",
    "PARAMETER",
    "    c  FLOAT  Constant",
    NULL
};

static char *CondHelp[] = {
    "NAME",
    "    ifthen, ifnotthen - Condition",
    "",
    "SYNOPSIS",
    "    <operator>  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    A value not equal to zero is treated as \"true\", zero is treated a \"false\".",
    "",
    "OPERATORS",
    "    ifthen     If then",
    "                        / i_2(t,x) if i_1(t,x) NE 0  AND  i_1(t,x) NE miss",
    "               o(t,x) =",
    "                        \\ miss     if i_1(t,x) EQ 0  OR   i_1(t,x) EQ miss",
    "    ifnotthen  If not then",
    "                        / i_2(t,x) if i_1(t,x) EQ 0  AND  i_1(t,x) NE miss",
    "               o(t,x) = ",
    "                        \\ miss     if i_1(t,x) NE 0  OR   i_1(t,x) EQ miss",
    NULL
};

static char *Cond2Help[] = {
    "NAME",
    "    ifthenelse - Condition",
    "",
    "SYNOPSIS",
    "    ifthenelse  ifile1 ifile2 ifile3 ofile",
    "",
    "DESCRIPTION",
    "              / i_2(t,x) if i_1(t,x) NE 0  AND  i_1(t,x) NE miss",
    "    o(t,x) = <  i_3(t,x) if i_1(t,x) EQ 0  AND  i_1(t,x) NE miss",
    "              \\ miss     if i_1(t,x) EQ miss",
    NULL
};

static char *CondcHelp[] = {
    "NAME",
    "    ifthenc, ifnotthenc - Condition",
    "",
    "SYNOPSIS",
    "    <operator>,c  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    ifthenc     If then constant",
    "                         / c      if i(t,x) NE 0  AND  i(t,x) NE miss",
    "                o(t,x) =",
    "                         \\ miss   if i(t,x) EQ 0  OR   i(t,x) EQ miss",
    "    ifnotthenc  If not then constant",
    "                         / c      if i(t,x) EQ 0  AND  i(t,x) NE miss",
    "                o(t,x) =",
    "                         \\ miss   if i(t,x) NE 0  OR   i(t,x) EQ miss",
    "",
    "PARAMETER",
    "    c  FLOAT  Constant",
    NULL
};

static char *EnsstatHelp[] = {
    "NAME",
    "    ensmin, ensmax, enssum, ensmean, ensavg, ensstd, ensvar - Statistical values over an ensemble",
    "",
    "SYNOPSIS",
    "    <operator>  ifiles ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    ensmin   Ensemble minimum",
    "    ensmax   Ensemble maximum",
    "    enssum   Ensemble sum",
    "    ensmean  Ensemble mean",
    "    ensavg   Ensemble average",
    "    ensstd   Ensemble standard deviation",
    "    ensvar   Ensemble variance",
    NULL
};

static char *FldstatHelp[] = {
    "NAME",
    "    fldmin, fldmax, fldsum, fldmean, fldavg, fldstd, fldvar - Statistical values over a field",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module compute statistical values of the input fields.",
    "    According to actual operator name the field",
    "    minimum, maximum, sum, average, standard deviation or variance",
    "    is written to ofile.",
    "",
    "OPERATORS",
    "    fldmin   Field minimum",
    "             o(t,1) = min{i(t',x'), t'=t}",
    "    fldmax   Field maximum",
    "             o(t,1) = max{i(t',x'), t'=t}",
    "    fldsum   Field sum",
    "             o(t,1) = sum{i(t,x)}",
    "    fldmean  Field mean",
    "             o(t,1) = mean{i(t',x'), t'=t}",
    "             weighted by area weights obtained by the input field.",
    "    fldavg   Field average",
    "             o(t,1) = avg{i(t',x'), t'=t}",
    "             weighted by area weights obtained by the input field.",
    "    fldstd   Field standard deviation",
    "             o(t,1) = sqrt{var{i(t',x'), t'=t}}",
    "             weighted by area weights obtained by the input field.",
    "    fldvar   Field variance",
    "             o(t,1) = var{i(t',x'), t'=t}",
    "             weighted by area weights obtained by the input field.",
    NULL
};

static char *ZonstatHelp[] = {
    "NAME",
    "    zonmin, zonmax, zonsum, zonmean, zonavg, zonstd, zonvar - Zonal statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module compute zonal statistical values of the input fields.",
    "    According to actual operator name the zonal",
    "    minimum, maximum, sum, average, standard deviation or variance",
    "    is written to ofile.",
    "",
    "OPERATORS",
    "    zonmin   Zonal minimum",
    "             For every latitude the minimum over all longitudes is computed.",
    "    zonmax   Zonal maximum",
    "             For every latitude the maximum over all longitudes is computed.",
    "    zonsum   Zonal sum",
    "             For every latitude the sum over all longitudes is computed.",
    "    zonmean  Zonal mean",
    "             For every latitude the mean over all longitudes is computed.",
    "    zonavg   Zonal average",
    "             For every latitude the average over all longitudes is computed.",
    "    zonstd   Zonal standard deviation",
    "             For every latitude the standard deviation over all longitudes is computed.",
    "    zonvar   Zonal variance",
    "             For every latitude the variance over all longitudes is computed.",
    NULL
};

static char *MerstatHelp[] = {
    "NAME",
    "    mermin, mermax, mersum, mermean, meravg, merstd, mervar - Meridional statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module compute meridional statistical values of the input fields.",
    "    According to actual operator name the meridional",
    "    minimum, maximum, sum, average, standard deviation or variance",
    "    is written to ofile.",
    "",
    "OPERATORS",
    "    mermin   Meridional minimum",
    "             For every longitude the minimum over all latitudes is computed.",
    "    mermax   Meridional maximum",
    "             For every longitude the maximum over all latitudes is computed.",
    "    mersum   Meridional sum",
    "             For every longitude the sum over all latitudes is computed.",
    "    mermean  Meridional mean",
    "             For every longitude the mean over all latitudes is computed.",
    "    meravg   Meridional average",
    "             For every longitude the average over all latitudes is computed.",
    "    merstd   Meridional standard deviation",
    "             For every longitude the standard deviation over all latitudes is computed.",
    "    mervar   Meridional variance",
    "             For every longitude the variance over all latitudes is computed.",
    NULL
};

static char *VertstatHelp[] = {
    "NAME",
    "    vertmin, vertmax, vertsum, vertmean, vertavg, vertstd - Vertical statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module compute statistical values over all levels of the ",
    "    input variabless.",
    "    According to actual operator name the vertical",
    "    minimum, maximum, sum, average, standard deviation or variance",
    "    is written to ofile.",
    "",
    "OPERATORS",
    "    vertmin   Vertical minimum",
    "              For every gridpoint the minimum over all levels is computed.",
    "    vertmax   Vertical maximum",
    "              For every gridpoint the maximum over all levels is computed.",
    "    vertsum   Vertical sum",
    "              For every gridpoint the sum over all levels is computed.",
    "    vertmean  Vertical mean",
    "              For every gridpoint the mean over all levels is computed.",
    "    vertavg   Vertical average",
    "              For every gridpoint the average over all levels is computed.",
    "    vertstd   Vertical standard deviation",
    "              For every gridpoint the standard deviation over all levels is computed.",
    NULL
};

static char *SelstatHelp[] = {
    "NAME",
    "    selmin, selmax, selsum, selmean, selavg, selstd - Time range statistical values",
    "",
    "SYNOPSIS",
    "    <operator>,nsets[,noffset[,nskip]]  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values for a selected number of time steps.",
    "    According to actual operator name, the average, minimum, maximum,",
    "    sum, average or standard deviation is written to ofile.",
    "",
    "OPERATORS",
    "    selmin   Time range minimum",
    "             For every adjacent sequence t1, ...., tn of timesteps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = min{i(t',x), t1 < t' <= tn}",
    "    selmax   Time range maximum",
    "             For every adjacent sequence t1, ...., tn of timesteps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = max{i(t',x), t1 < t' <= tn}",
    "    selsum   Time range sum",
    "             For every adjacent sequence t1, ...., tn of timesteps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = sum{i(t',x), t1 < t' <= tn}",
    "    selmean  Time range mean",
    "             For every adjacent sequence t1, ...., tn of timesteps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = mean{i(t',x), t1 < t' <= tn}",
    "    selavg   Time range average",
    "             For every adjacent sequence t1, ...., tn of timesteps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = avg{i(t',x), t1 < t' <= tn}",
    "    selstd   Time range standard deviation",
    "             For every adjacent sequence t1, ...., tn of timesteps of the same ",
    "             selected time range, it is",
    "             ",
    "             o(t,x) = sqrt{var{i(t',x), t1 < t' <= tn}}",
    "",
    "PARAMETER",
    "    nsets    INTEGER  Number of input timesteps for each output timestep",
    "    noffset  INTEGER  Number of input timesteps skipped before the first timestep range (optional)",
    "    nskip    INTEGER  Number of input timesteps skipped between timestep ranges (optional)",
    NULL
};

static char *RunstatHelp[] = {
    "NAME",
    "    runmin, runmax, runsum, runmean, runavg, runstd - Running statistical values",
    "",
    "SYNOPSIS",
    "    <operator>,nts  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes running statistical ",
    "    values over a selected number of time steps.",
    "    Depending on the actual operator name the minimum, ",
    "    maximum, sum, average or standard deviation of a selected number ",
    "    of consecutive time steps read from ifile is written to ofile.",
    "    The date information in ofile is the date of the medium ",
    "    contributing time step in ifile.",
    "",
    "OPERATORS",
    "    runmin   Running minimum",
    "             o(t+(nts-1)/2,x) = min{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runmax   Running maximum",
    "             o(t+(nts-1)/2,x) = max{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runsum   Running sum",
    "             o(t+(nts-1)/2,x) = sum{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runmean  Running mean",
    "             o(t+(nts-1)/2,x) = mean{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runavg   Running average",
    "             o(t+(nts-1)/2,x) = avg{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}",
    "    runstd   Running standard deviation",
    "             o(t+(nts-1)/2,x) = sqrt{var{i(t,x), i(t+1,x), ..., i(t+nts-1,x)}}",
    "",
    "PARAMETER",
    "    nts  INTEGER  Number of timesteps",
    NULL
};

static char *TimstatHelp[] = {
    "NAME",
    "    timmin, timmax, timsum, timmean, timavg, timstd - Statistical values over all time steps",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical  values over all ",
    "    time steps in ifile.",
    "    Depending on the actual operator name the minimum, ",
    "    maximum, sum, average or standard deviation of all",
    "    time steps read from ifile is written to ofile.",
    "    The date information for a time step in ofile",
    "    is the date of the last contributing time step in ifile.",
    "",
    "OPERATORS",
    "    timmin   Time minimum",
    "             o(1,x) = min{i(t',x'), x'=x}",
    "    timmax   Time maximum",
    "             o(1,x) = max{i(t',x'), x'=x}",
    "    timsum   Time sum",
    "             o(1,x) = sum{i(t,x)}",
    "    timmean  Time mean",
    "             o(1,x) = mean{i(t',x'), x'=x}",
    "    timavg   Time average",
    "             o(1,x) = avg{i(t',x'), x'=x}",
    "    timstd   Time standard deviation",
    "             o(1,x) = sqrt{var{i(t',x'), x'=x}}",
    NULL
};

static char *HourstatHelp[] = {
    "NAME",
    "    hourmin, hourmax, hoursum, hourmean, houravg, hourstd - Hourly statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over time steps ",
    "    of the same hour.",
    "    Depending on the actual operator name the minimum, ",
    "    maximum, sum, average or standard deviation of",
    "    time steps of the same hour is written to ofile.",
    "    The date information for a time step in ofile",
    "    is the date of the last contributing time step in ifile.",
    "",
    "OPERATORS",
    "    hourmin   Hourly minimum",
    "              For every adjacent sequence t_1, ...,t_n of field of the same hour, it is",
    "              ",
    "              o(t,x) = min{i(t',x), t_1<t'<=t_n}",
    "    hourmax   Hourly maximum",
    "              For every adjacent sequence t_1, ...,t_n of field of the same hour, it is",
    "              ",
    "              o(t,x) = max{i(t',x), t_1<t'<=t_n}",
    "    hoursum   Hourly sum",
    "              For every adjacent sequence t_1, ...,t_n of field of the same hour, it is",
    "              ",
    "              o(t,x) = sum{i(t',x)}",
    "    hourmean  Hourly mean",
    "              For every adjacent sequence t_1, ...,t_n of field of the same day, it is",
    "              ",
    "              o(t,x) = mean{i(t',x), t_1<t'<=t_n}",
    "    houravg   Hourly average",
    "              For every adjacent sequence t_1, ...,t_n of field of the same day, it is",
    "              ",
    "              o(t,x) = avg{i(t',x), t_1<t'<=t_n}",
    "    hourstd   Hourly standard deviation",
    "              For every adjacent sequence t_1, ...,t_n of field of the same hour, it is",
    "              ",
    "              o(t,x) = sqrt{var{i(t',x), t_1<t'<=t_n}",
    NULL
};

static char *DaystatHelp[] = {
    "NAME",
    "    daymin, daymax, daysum, daymean, dayavg, daystd - Daily statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over time steps ",
    "    of the same day.",
    "    Depending on the actual operator name the minimum, ",
    "    maximum, sum, average or standard deviation of",
    "    time steps of the same day is written to ofile.",
    "    The date information for a time step in ofile",
    "    is the date of the last contributing time step in ifile.",
    "",
    "OPERATORS",
    "    daymin   Daily minimum",
    "             For every adjacent sequence t_1, ...,t_n of field of the same day, it is",
    "             ",
    "             o(t,x) = min{i(t',x), t_1<t'<=t_n}",
    "    daymax   Daily maximum",
    "             For every adjacent sequence t_1, ...,t_n of field of the same day, it is",
    "             ",
    "             o(t,x) = max{i(t',x), t_1<t'<=t_n}",
    "    daysum   Daily sum",
    "             For every adjacent sequence t_1, ...,t_n of field of the same month, it is",
    "             ",
    "             o(t,x) = sum{i(t',x)}",
    "    daymean  Daily mean",
    "             For every adjacent sequence t_1, ...,t_n of field of the same day, it is",
    "             ",
    "             o(t,x) = mean{i(t',x), t_1<t'<=t_n}",
    "    dayavg   Daily average",
    "             For every adjacent sequence t_1, ...,t_n of field of the same day, it is",
    "             ",
    "             o(t,x) = avg{i(t',x), t_1<t'<=t_n}",
    "    daystd   Daily standard deviation",
    "             For every adjacent sequence t_1, ...,t_n of field of the same day, it is",
    "             ",
    "             o(t,x) = sqrt{var{i(t',x), t_1<t'<=t_n}",
    NULL
};

static char *MonstatHelp[] = {
    "NAME",
    "    monmin, monmax, monsum, monmean, monavg, monstd - Monthly statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over time steps ",
    "    of the same month.",
    "    Depending on the actual operator name the minimum, ",
    "    maximum, sum, average or standard deviation of",
    "    time steps of the same month is written to ofile.",
    "    The date information for a time step in ofile",
    "    is the date of the last contributing time step in ifile.",
    "",
    "OPERATORS",
    "    monmin   Monthly minimum",
    "             For every adjacent sequence t_1, ...,t_n of field of the same month, it is",
    "             ",
    "             o(t,x) = min{i(t',x), t_1<t'<=t_n}",
    "    monmax   Monthly maximum",
    "             For every adjacent sequence t_1, ...,t_n of field of the same month, it is",
    "             ",
    "             o(t,x) = max{i(t',x), t_1<t'<=t_n}",
    "    monsum   Monthly sum",
    "             For every adjacent sequence t_1, ...,t_n of field of the same month, it is",
    "             ",
    "             o(t,x) = sum{i(t',x)}",
    "    monmean  Monthly mean",
    "             For every adjacent sequence t_1, ...,t_n of field of the same month, it is",
    "             ",
    "             o(t,x) = mean{i(t',x), t_1<t'<=t_n}",
    "    monavg   Monthly average",
    "             For every adjacent sequence t_1, ...,t_n of field of the same month, it is",
    "             ",
    "             o(t,x) = avg{i(t',x), t_1<t'<=t_n}",
    "    monstd   Monthly standard deviation",
    "             For every adjacent sequence t_1, ...,t_n of field of the same month, it is",
    "             ",
    "             o(t,x) = sqrt{var{i(t',x), t_1 < t' <= t_n}}",
    NULL
};

static char *YearstatHelp[] = {
    "NAME",
    "    yearmin, yearmax, yearsum, yearmean, yearavg, yearstd - Yearly statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module computes statistical values over time steps ",
    "    of the same year.",
    "    Depending on the actual operator name the minimum, ",
    "    maximum, sum, average or standard deviation of",
    "    time steps of the same year is written to ofile.",
    "    The date information for a time step in ofile",
    "    is the date of the last contributing time step in ifile.",
    "",
    "OPERATORS",
    "    yearmin   Yearly minimum",
    "              For every adjacent sequence t_1, ...,t_n of field of the same year, it is",
    "              ",
    "              o(t,x) = min{i(t',x), t_1<t'<=t_n}",
    "    yearmax   Yearly maximum",
    "              For every adjacent sequence t_1, ...,t_n of field of the same year, it is",
    "              ",
    "              o(t,x) = max{i(t',x), t_1<t'<=t_n}",
    "    yearsum   Yearly sum",
    "              For every adjacent sequence t_1, ...,t_n of field of the same year, it is",
    "              ",
    "              o(t,x) = sum{i(t',x)}",
    "    yearmean  Yearly mean",
    "              For every adjacent sequence t_1, ...,t_n of field of the same year, it is",
    "              ",
    "              o(t,x) = mean{i(t',x), t_1<t'<=t_n}",
    "    yearavg   Yearly average",
    "              For every adjacent sequence t_1, ...,t_n of field of the same year, it is",
    "              ",
    "              o(t,x) = avg{i(t',x), t_1<t'<=t_n}",
    "    yearstd   Yearly standard deviation",
    "              For every adjacent sequence t_1, ...,t_n of field of the same year, it is",
    "              ",
    "              o(t,x) = sqrt{var{i(t',x), t_1 < t' <= t_n}}",
    NULL
};

static char *SeasstatHelp[] = {
    "NAME",
    "    seasmin, seasmax, seassum, seasmean, seasavg, seasstd - Seasonally statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    For every adjacent sequence t1, ...., tn of timesteps of the same ",
    "    year and season, where december belongs to the northern hemispheric",
    "    winter of the next year.",
    "    Be careful about the first and the last timestep, they may be incorrect",
    "    DJF values.",
    "",
    "OPERATORS",
    "    seasmin   Seasonally minimum",
    "              o(t,x) = min{i(t',x), t1 < t' <= tn}",
    "    seasmax   Seasonally maximum",
    "              o(t,x) = max{i(t',x), t1 < t' <= tn}",
    "    seassum   Seasonally sum",
    "              o(t,x) = sum{i(t',x), t1 < t' <= tn}",
    "    seasmean  Seasonally mean",
    "              o(t,x) = mean{i(t',x), t1 < t' <= tn}",
    "    seasavg   Seasonally average",
    "              o(t,x) = avg{i(t',x), t1 < t' <= tn}",
    "    seasstd   Seasonally standard deviation",
    "              o(t,x) = sqrt{var{i(t',x), t1 < t' <= tn}}",
    NULL
};

static char *YdaystatHelp[] = {
    "NAME",
    "    ydaymin, ydaymax, ydaymean, ydayavg, ydaystd - Multi-year daily statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module writes to ofile, according to actual operator name,",
    "    the minimum, maximum, sum, average or standard deviation ",
    "    of each day of year in ifile.",
    "    The date information in an output field is the date of the last contributing",
    "    input field.",
    "",
    "OPERATORS",
    "    ydaymin   Multi-year daily minimum",
    "              o(001,x) = min{i(t,x), day(i(t)) = 001}",
    "                               ...",
    "              o(366,x) = min{i(t,x), day(i(t)) = 366}",
    "    ydaymax   Multi-year daily maximum",
    "              o(001,x) = max{i(t,x), day(i(t)) = 001}",
    "                               ...",
    "              o(366,x) = max{i(t,x), day(i(t)) = 366}",
    "    ydaymean  Multi-year daily mean",
    "              o(001,x) = mean{i(t,x), day(i(t)) = 001}",
    "                               ...",
    "              o(366,x) = mean{i(t,x), day(i(t)) = 366}",
    "    ydayavg   Multi-year daily average",
    "              o(001,x) = avg{i(t,x), day(i(t)) = 001}",
    "                               ...",
    "              o(366,x) = avg{i(t,x), day(i(t)) = 366}",
    "    ydaystd   Multi-year daily standard deviation",
    "              o(001,x) = sqrt{var{i(t,x), day(i(t)) = 001}}",
    "                               ...",
    "              o(366,x) = sqrt{var{i(t,x), day(i(t)) = 366}}",
    NULL
};

static char *YmonstatHelp[] = {
    "NAME",
    "    ymonmin, ymonmax, ymonmean, ymonavg, ymonstd - Multi-year monthly statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module writes to ofile, according to actual operator name,",
    "    the minimum, maximum, sum, average or standard deviation ",
    "    of each month of year in ifile.",
    "    The date information in an output field is the date of the last contributing",
    "    input field.",
    "",
    "OPERATORS",
    "    ymonmin   Multi-year monthly minimum",
    "              o(01,x) = min{i(t,x), month(i(t)) = 01}",
    "                               ...",
    "              o(12,x) = min{i(t,x), month(i(t)) = 12}",
    "    ymonmax   Multi-year monthly maximum",
    "              o(01,x) = max{i(t,x), month(i(t)) = 01}",
    "                               ...",
    "              o(12,x) = max{i(t,x), month(i(t)) = 12}",
    "    ymonmean  Multi-year monthly mean",
    "              o(01,x) = mean{i(t,x), month(i(t)) = 01}",
    "                               ...",
    "              o(12,x) = mean{i(t,x), month(i(t)) = 12}",
    "    ymonavg   Multi-year monthly average",
    "              o(01,x) = avg{i(t,x), month(i(t)) = 01}",
    "                               ...",
    "              o(12,x) = avg{i(t,x), month(i(t)) = 12}",
    "    ymonstd   Multi-year monthly standard deviation",
    "              o(01,x) = sqrt{var{i(t,x), month(i(t)) = 01}}",
    "                               ...",
    "              o(12,x) = sqrt{var{i(t,x), month(i(t)) = 12}}",
    NULL
};

static char *YseasstatHelp[] = {
    "NAME",
    "    yseasmin, yseasmax, yseasmean, yseasavg, yseasstd - Multi-year seasonally statistical values",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module writes to ofile, according to actual operator name,",
    "    the minimum, maximum, sum, average or standard deviation ",
    "    of each season in ifile.",
    "    The date information in an output field is the date of the last contributing",
    "    input field.",
    "",
    "OPERATORS",
    "    yseasmin   Multi-year seasonally minimum",
    "               o(1,x) = min{i(t,x), month(i(t)) = 12, 01, 02}",
    "               o(2,x) = min{i(t,x), month(i(t)) = 03, 04, 05}",
    "               o(3,x) = min{i(t,x), month(i(t)) = 06, 07, 08}",
    "               o(4,x) = min{i(t,x), month(i(t)) = 09, 10, 11}",
    "    yseasmax   Multi-year seasonally maximum",
    "               o(1,x) = max{i(t,x), month(i(t)) = 12, 01, 02}",
    "               o(2,x) = max{i(t,x), month(i(t)) = 03, 04, 05}",
    "               o(3,x) = max{i(t,x), month(i(t)) = 06, 07, 08}",
    "               o(4,x) = max{i(t,x), month(i(t)) = 09, 10, 11}",
    "    yseasmean  Multi-year seasonally mean",
    "               o(1,x) = mean{i(t,x), month(i(t)) = 12, 01, 02}",
    "               o(2,x) = mean{i(t,x), month(i(t)) = 03, 04, 05}",
    "               o(3,x) = mean{i(t,x), month(i(t)) = 06, 07, 08}",
    "               o(4,x) = mean{i(t,x), month(i(t)) = 09, 10, 11}",
    "    yseasavg   Multi-year seasonally average",
    "               o(1,x) = avg{i(t,x), month(i(t)) = 12, 01, 02}",
    "               o(2,x) = avg{i(t,x), month(i(t)) = 03, 04, 05}",
    "               o(3,x) = avg{i(t,x), month(i(t)) = 06, 07, 08}",
    "               o(4,x) = avg{i(t,x), month(i(t)) = 09, 10, 11}",
    "    yseasstd   Multi-year seasonally standard deviation",
    "               o(1,x) = sqrt{var{i(t,x), month(i(t)) = 12, 01, 02}}",
    "               o(2,x) = sqrt{var{i(t,x), month(i(t)) = 03, 04, 05}}",
    "               o(3,x) = sqrt{var{i(t,x), month(i(t)) = 06, 07, 08}}",
    "               o(4,x) = sqrt{var{i(t,x), month(i(t)) = 09, 10, 11}}",
    NULL
};

static char *DetrendHelp[] = {
    "NAME",
    "    detrend - Detrend",
    "",
    "SYNOPSIS",
    "    detrend  ifile ofile",
    "",
    "DESCRIPTION",
    "    Every time series in ifile is linearly detrended.",
    "    For every field element x only those timesteps t belong",
    "    to the sample S(x), which have i(t,x) NE miss.",
    "    This operator has to keep the fields of all timesteps concurrently in the memory.",
    "    If not enough memory is available, use the operators trend and subtrend.",
    NULL
};

static char *TrendHelp[] = {
    "NAME",
    "    trend - Trend",
    "",
    "SYNOPSIS",
    "    trend  ifile ofile1 ofile2",
    "",
    "DESCRIPTION",
    "    The values of the input file ifile are assumed to be distributed as",
    "    N(a+b*t,S^2) with unknown a, b and S^2. This operator estimates the",
    "    parameter a and b.",
    "    For every field element x only those timesteps t belong",
    "    to the sample S(x), which have i(t,x) NE miss.",
    "    The estimation for a is stored in ofile1 and that for b is stored in ofile2.",
    "    To subtract the trend from the data see operator subtrend.",
    NULL
};

static char *SubtrendHelp[] = {
    "NAME",
    "    subtrend - Subtrend",
    "",
    "SYNOPSIS",
    "    subtrend  ifile1 ifile2 ifile3 ofile",
    "",
    "DESCRIPTION",
    "    This operator is for subtracting a trend computed by the operator trend.",
    "    The typical call for detrend the data in ifile and to store the detrended data in ofile is:",
    "    ",
    "      cdo trend ifile afile bfile",
    "      cdo subtrend ifile afile bfile ofile",
    "    ",
    "    It is",
    "    ",
    "    o(t,x) = i_1(t,x) - (i_2(1,x) + i_3(1,x)*t)",
    NULL
};

static char *InterpolateHelp[] = {
    "NAME",
    "    remapcon, remapbil, remapbic, remapdis - SCRIP grid interpolation",
    "",
    "SYNOPSIS",
    "    <operator>,grid  ifile ofile",
    "",
    "DESCRIPTION",
    "    This module contains operators to interpolate all input fields to a new grid.",
    "    Each operator is using a different remapping method.",
    "",
    "OPERATORS",
    "    remapcon  Conservative remapping",
    "              First order conservative remapping.",
    "    remapbil  Bilinear interpolation",
    "              Bilinear interpolation (only rectangular grids).",
    "    remapbic  Bicubic interpolation",
    "              Bicubic interpolation (only rectangular grids).",
    "    remapdis  Distance-weighted averaging",
    "              Distance-weighted average of the four nearest neighbor values.",
    "",
    "PARAMETER",
    "    grid  STRING  Grid description file or name of the target grid",
    "",
    "ENVIRONMENT",
    "    NORMALIZE_OPT",
    "        This variable is used to choose the normalization of the conservative ",
    "        remapping. By default, NORMALIZE_OPT is set to be 'fracarea' and will",
    "        include the destination area fraction in the output weights; other ",
    "        options are 'none' and 'destarea' (for more information see {SCRIP}).",
    NULL
};

static char *GenweightsHelp[] = {
    "NAME",
    "    gencon, genbil, genbic, gendis - SCRIP grid interpolation weights",
    "",
    "SYNOPSIS",
    "    <operator>,grid  ifile ofile",
    "",
    "DESCRIPTION",
    "    Grid interpolation can be a very time consuming process.",
    "    Especially when you have data on an unstructured grid or",
    "    on a large grid. In this case you can split the SCRIP",
    "    interpolation process into two parts. First generate the",
    "    interpolation weights, this is the most time consuming part.",
    "    And then you can reuse these interpolation weights for",
    "    every remapping process. You can use this method only",
    "    if all input fields are on the same grid and a possibly",
    "    mask (missing values) does not change.",
    "    This module contains operators to generate SCRIP interpolation ",
    "    weights of the first input field.",
    "    Each operator is using a different interpolation method.",
    "",
    "OPERATORS",
    "    gencon  Generate conservative interpolation weights",
    "            Generate first order conservative interpolation weights and",
    "            write the result to a file.",
    "    genbil  Generate bilinear interpolation weights",
    "            Bilinear interpolation (only rectangular grids) and ",
    "            write the result to a file.",
    "    genbic  Generate bicubic interpolation weights",
    "            Generate bicubic interpolation (only rectangular grids)",
    "            and write the result to a file.",
    "    gendis  Generate distance-weighted averaging weights",
    "            Generate distance-weighted average weights of the four",
    "            nearest neighbor values write the result to a file.",
    "",
    "PARAMETER",
    "    grid  STRING  Grid description file or name of the target grid",
    "",
    "ENVIRONMENT",
    "    NORMALIZE_OPT",
    "        This variable is used to choose the normalization of the conservative ",
    "        interpolation. By default, NORMALIZE_OPT is set to be 'fracarea' and will",
    "        include the destination area fraction in the output weights; other ",
    "        options are 'none' and 'destarea' (for more information see {SCRIP}).",
    NULL
};

static char *RemapHelp[] = {
    "NAME",
    "    remap - SCRIP grid remapping",
    "",
    "SYNOPSIS",
    "    remap,grid,weights  ifile ofile",
    "",
    "DESCRIPTION",
    "    This operator remaps all input fields to a new grid.",
    "    The remap type and the interpolation weights of one grid are read",
    "    from a netCDF file.",
    "    The netCDF file with the weights must follow the SCRIP convention.",
    "    Normaly these weights come from a previous call to gen* or",
    "    was created by the original SCRIP package.",
    "",
    "PARAMETER",
    "    grid     STRING  Grid description file or name of the target grid",
    "    weights  STRING  Interpolation weights (SCRIP netCDF file)",
    NULL
};

static char *IntgridHelp[] = {
    "NAME",
    "    interpolate - PINGO grid interpolation",
    "",
    "SYNOPSIS",
    "    interpolate,grid  ifile ofile",
    "",
    "DESCRIPTION",
    "    Grid interpolation from PINGO (only rectangular grids).",
    "",
    "PARAMETER",
    "    grid  STRING  Grid description file or name of the target grid",
    NULL
};

static char *VertintHelp[] = {
    "NAME",
    "    ml2pl, ml2hl - Vertical interpolation",
    "",
    "SYNOPSIS",
    "    ml2pl,plevels  ifile ofile",
    "    ml2hl,hlevels  ifile ofile",
    "",
    "DESCRIPTION",
    "    Interpolate fields on hybrid model level to pressure or height level.",
    "    The input file must contain the log. surface pressure (LSP/code152)",
    "    or the surface pressure (APS/code134).",
    "    To interpolate the temperature or the geopotential height, ",
    "    the orography (GEOSP/code129) is also needed.",
    "",
    "OPERATORS",
    "    ml2pl  Model to pressure level interpolation",
    "           Interpolate fields on hybrid model level to pressure level.",
    "    ml2hl  Model to height level interpolation",
    "           Interpolate fields on hybrid model level to height level.",
    "",
    "PARAMETER",
    "    plevels  FLOAT  Pressure levels in pascal",
    "    hlevels  FLOAT  Height levels in meter (max level: 65535 m)",
    "",
    "ENVIRONMENT",
    "    EXTRAPOLATE",
    "        If set to 1 extrapolate missing values.",
    NULL
};

static char *InttimeHelp[] = {
    "NAME",
    "    inttime - Time interpolation",
    "",
    "SYNOPSIS",
    "    inttime,date,time[,inc]  ifile ofile",
    "",
    "DESCRIPTION",
    "    Linear interpolation between timesteps.",
    "",
    "PARAMETER",
    "    date  STRING  Start date (format YYYY-MM-DD)",
    "    time  STRING  Start time (format HH:MM)",
    "    inc   STRING  Optional increment (minutes, hours or days) [default: 0hour]",
    NULL
};

static char *IntyearHelp[] = {
    "NAME",
    "    intyear - Year interpolation",
    "",
    "SYNOPSIS",
    "    intyear,years  ifile1 ifile2 ofile",
    "",
    "DESCRIPTION",
    "    Linear interpolation between two years.",
    "",
    "PARAMETER",
    "    years  INTEGER  Comma separated list of years",
    NULL
};

static char *SpectralHelp[] = {
    "NAME",
    "    sp2gp, sp2gpl, gp2sp, gp2spl, sp2sp, spcut - Spectral transformation",
    "",
    "SYNOPSIS",
    "    sp2gp  ifile ofile",
    "    sp2gpl  ifile ofile",
    "    gp2sp  ifile ofile",
    "    gp2spl  ifile ofile",
    "    sp2sp,trunc  ifile ofile",
    "    spcut,wnums  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    sp2gp   Spectral to gridpoint",
    "            Convert all spectral fields to Gaussian grid.",
    "            The number of latitudes of the resulting Gaussian grid",
    "            is calculated from the triangular truncation by:",
    "            ",
    "               nlat = NINT((trunc*3 + 1.)/2.)",
    "    sp2gpl  Spectral to gridpoint linear",
    "            Convert all spectral fields to Gaussian grid.",
    "            The number of latitudes of the resulting Gaussian grid",
    "            is calculated from the triangular truncation by:",
    "            ",
    "               nlat = NINT((trunc*2 + 1.)/2.)",
    "            ",
    "            Use this operator to convert ERA40 data e.g. from TL159 to N80.",
    "    gp2sp   Gridpoint to spectral",
    "            Convert all Gaussian gridpoint fields to spectral.",
    "            The triangular truncation of the resulting spherical harmonics",
    "            is calculated from the number of latitudes by:",
    "            ",
    "               trunc = (nlat*2 - 1) / 3",
    "    gp2spl  Gridpoint to spectral linear",
    "            Convert all Gaussian gridpoint fields to spectral.",
    "            The triangular truncation of the resulting spherical harmonics",
    "            is calculated from the number of latitudes by:",
    "            ",
    "               trunc = (nlat*2 - 1) / 2",
    "            ",
    "            Use this operator to convert ERA40 data e.g. from N80 to TL159",
    "            instead of T106.",
    "    sp2sp   Spectral to spectral",
    "            Change the triangular truncation of all spectral fields.",
    "            The operator performs downward conversion by cutting the resolution.",
    "            Upward conversions are achieved by filling in zeros.",
    "    spcut   Cut spectral wave number",
    "            Set the user defined wave numbers to zero.",
    "",
    "PARAMETER",
    "    trunc  INTEGER  New spectral resolution",
    "    wnums  INTEGER  Comma separated list of wave numbers",
    NULL
};

static char *WindHelp[] = {
    "NAME",
    "    uv2dv, dv2uv - Wind transformation",
    "",
    "SYNOPSIS",
    "    <operator>  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    uv2dv  U and V wind to divergence and vorticity",
    "           Calculate spherical harmonic coefficients of divergence and vorticity",
    "           from U and V wind.",
    "    dv2uv  Divergence and vorticity to U and V wind",
    "           Calculate U and V wind on a gaussian grid from divergence and vorticity.",
    NULL
};

static char *TimsortHelp[] = {
    "NAME",
    "    timsort - Timsort",
    "",
    "SYNOPSIS",
    "    timsort  ifile ofile",
    "",
    "DESCRIPTION",
    "    Sorts for every field position the elements in ascending order.",
    "    After sorting it is",
    "    ",
    "    o(t_1,x) < o(t_2,x)      forall (t_1<t_2),x",
    NULL
};

static char *OutputHelp[] = {
    "NAME",
    "    output, outputf, outputint, outputsrv, outputext - Formatted output",
    "",
    "SYNOPSIS",
    "    output  ifiles",
    "    outputf,format,nelem  ifiles",
    "    outputint  ifiles",
    "    outputsrv  ifiles",
    "    outputext  ifiles",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    output     ASCII output",
    "               Prints all values to standard output.",
    "               Each row has 6 elements with the C-style format \"\%13.6g\".",
    "    outputf    Formatted output",
    "               Prints all values to standard output.",
    "               The format and number of elements for each column",
    "               can be specified by the parameters.",
    "    outputint  Integer output",
    "               Prints all values rounded to the nearest intergers to standard output.",
    "    outputsrv  SERVICE output",
    "               Prints all values to standard output.",
    "               Each field with a header of 8 integers (SERVICE likely).",
    "    outputext  EXTRA output",
    "               Prints all values to standard output.",
    "               Each field with a header of 4 integers (EXTRA likely).",
    "",
    "PARAMETER",
    "    format  STRING C-style format for one element",
    "    nelem   INTEGER Number of elements for each row",
    NULL
};

static char *VargenHelp[] = {
    "NAME",
    "    const, random - ",
    "",
    "SYNOPSIS",
    "    const,const,grid  ofile",
    "    random,grid  ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    const   Constant variable",
    "            Generates a constant variable.",
    "    random  Variable with random values",
    "            Generates a variable with rectangularly distrubuted random numbers in the interval [0,1].",
    "",
    "PARAMETER",
    "    const  FLOAT   Constant",
    "    grid   STRING  Grid description file or name",
    NULL
};

static char *VardupHelp[] = {
    "NAME",
    "    vardup, varmul - Variable duplication",
    "",
    "SYNOPSIS",
    "    vardup  ifile ofile",
    "    varmul,nmul  ifile ofile",
    "",
    "DESCRIPTION",
    "",
    "OPERATORS",
    "    vardup  Duplicate variables",
    "            Duplicate all variables.",
    "    varmul  Multiply variables",
    "            Multiply all variables.",
    "",
    "PARAMETER",
    "    nmul  INTEGER  Number of multiplications",
    NULL
};

static char *GradsdesHelp[] = {
    "NAME",
    "    gradsdes, gradsdes2 - GrADS data descriptor file",
    "",
    "SYNOPSIS",
    "    <operator>  ifile",
    "",
    "DESCRIPTION",
    "    Creates a GrADS data descriptor file. Supported file formats",
    "    are GRIB, SERVICE, EXTRA and IEG. For GRIB files the GrADS map",
    "    file is also generated.",
    "    For SERVICE and EXTRA files the grid must be specified with",
    "    the CDO option '-g <grid>'.",
    "    This operator takes ifile in order to create filenames for",
    "    the descriptor (ofile.ctl) and the map (ofile.gmp) file.",
    "",
    "OPERATORS",
    "    gradsdes   GrADS data descriptor file",
    "               Creates a GrADS data descriptor file. ",
    "               Generated a machine specific version 1 GrADS map for GRIB datasets.",
    "    gradsdes2  GrADS data descriptor file (version 2 map)",
    "               Creates a GrADS data descriptor file.",
    "               Generated a machine independent version 2 GrADS map for GRIB datasets.",
    NULL
};

static char *RotuvHelp[] = {
    "NAME",
    "    rotuvb - Rotation",
    "",
    "SYNOPSIS",
    "    rotuvb,u,v,...  ifile ofile",
    "",
    "DESCRIPTION",
    "    Operator to perform a backward transformation of velocity",
    "    components u and v from an rotated spherical system to a",
    "    geographical system",
    "",
    "PARAMETER",
    "    u,v,...  STRING  Pairs of zonal and meridional velocity components",
    NULL
};

static char *MastrfuHelp[] = {
    "NAME",
    "    mastrfu - Mass stream function",
    "",
    "SYNOPSIS",
    "    mastrfu  ifile ofile",
    "",
    "DESCRIPTION",
    "    Compute the mass stream function (ECHAM code272).",
    "    The input field must be a zonal mean of v-velocity (code132) on pressure levels.",
    NULL
};
